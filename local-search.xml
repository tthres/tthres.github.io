<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>poco库的基本使用</title>
    <link href="/2025/08/19/2025-8-19-poco%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <url>/2025/08/19/2025-8-19-poco%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>记录一下在Windows中使用poco库的一些步骤，包括编译，基本使用等，提供一个方便的poco开发框架</p><h2 id="POCO库官网"><a href="#POCO库官网" class="headerlink" title="POCO库官网"></a>POCO库官网</h2><p><a href="https://pocoproject.org/">https://pocoproject.org/</a></p><h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><p>克隆下Poco，根目录存在CMakeLists.txt，直接使用cmake编译即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> cmake-build<br><span class="hljs-built_in">cd</span> cmake-build<br>cmake ..<br>cmake --build .<br></code></pre></td></tr></table></figure><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>上一步的编译产生的目录</p><div style="width: 33.33%; float: left;">  <img src="/img/2025-8-219-poco库的基本使用/1.png" alt="1" style="width: 100%;"></div><div style="clear: both;"></div><br><p>其中，需要用到的就只有<strong>bin</strong>和<strong>lib</strong>目录。</p><p>这里举一个cmake使用poco库的例子：<br>main.cpp:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Poco/Util/ServerApplication.h&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerApp</span> : <span class="hljs-keyword">public</span> Poco::Util::ServerApplication<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ServerApp</span>() &#123;&#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">ServerApp</span>() &#123;&#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">initialize</span><span class="hljs-params">(Poco::Util::Application&amp; self)</span> <span class="hljs-keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;ServerApp::initialize()&quot;</span> &lt;&lt; std::endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">uninitialize</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;ServerApp::uninitialize()&quot;</span> &lt;&lt; std::endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span>  <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;std::string&gt;&amp; args)</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;ServerApp::main()&quot;</span> &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> Application::EXIT_OK;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    ServerApp app;<br>    <span class="hljs-keyword">return</span> app.<span class="hljs-built_in">run</span>(argc, argv);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码需要依赖poco的基本头文件和库文件，需要将对应文件include和lib目录添加到CMakeLists.txt中<br>CMakeLists.txt:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.10</span> FATAL_ERROR)<br><span class="hljs-keyword">project</span>(PocoDemo)<br><br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">20</span>)<br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="hljs-keyword">ON</span>)<br><span class="hljs-keyword">set</span>(CMAKE_CXX_EXTENSIONS <span class="hljs-keyword">OFF</span>)<br><br><span class="hljs-keyword">set</span>(POCO_FOUNDATION_INCLUDE_DIR <span class="hljs-string">&quot;$&#123;CMAKE_SOURCE_DIR&#125;/third_parties/poco/Foundation/include&quot;</span>)<br><span class="hljs-keyword">set</span>(POCO_FOUNDATION_LIB_DIR <span class="hljs-string">&quot;$&#123;CMAKE_SOURCE_DIR&#125;/third_parties/poco/Foundation/lib&quot;</span>)<br><br><span class="hljs-keyword">add_executable</span>(<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span>)<br><br><span class="hljs-keyword">set_target_properties</span>(<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span> PROPERTIES FOLDER <span class="hljs-string">&quot;demo&quot;</span>)<br><br><span class="hljs-keyword">set</span>(SRCS_DEMO <span class="hljs-string">&quot;main.cpp&quot;</span>)<br><br><span class="hljs-keyword">source_group</span>(TREE <span class="hljs-variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span> FILES <span class="hljs-variable">$&#123;SRCS_DEMO&#125;</span>)<br><br><span class="hljs-keyword">target_sources</span>(<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span> PRIVATE <span class="hljs-variable">$&#123;SRCS_DEMO&#125;</span>)<br><br><span class="hljs-keyword">add_custom_command</span>(<span class="hljs-keyword">TARGET</span> <span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span> POST_BUILD<br>                    <span class="hljs-keyword">COMMAND</span> <span class="hljs-variable">$&#123;CMAKE_COMMAND&#125;</span> -E copy_if_different<br>                    <span class="hljs-string">&quot;$&#123;POCO_FOUNDATION_LIB_DIR&#125;/PocoFoundationd.dll&quot;</span><br>                    <span class="hljs-string">&quot;$&#123;POCO_FOUNDATION_LIB_DIR&#125;/PocoDatad.dll&quot;</span><br>                    <span class="hljs-string">&quot;$&#123;POCO_FOUNDATION_LIB_DIR&#125;/PocoUtild.dll&quot;</span><br>                    <span class="hljs-string">&quot;$&#123;POCO_FOUNDATION_LIB_DIR&#125;/PocoXMLd.dll&quot;</span><br>                    <span class="hljs-string">&quot;$&#123;POCO_FOUNDATION_LIB_DIR&#125;/PocoJSONd.dll&quot;</span><br>                   $&lt;TARGET_FILE_DIR:<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span>&gt;<br>)<br><br><span class="hljs-comment">#  add poco libs</span><br><span class="hljs-keyword">target_include_directories</span>(<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span> PRIVATE <span class="hljs-variable">$&#123;POCO_FOUNDATION_INCLUDE_DIR&#125;</span>)<br><span class="hljs-keyword">target_link_directories</span>(<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span> PRIVATE <span class="hljs-variable">$&#123;POCO_FOUNDATION_LIB_DIR&#125;</span>)<br><span class="hljs-keyword">target_link_libraries</span>(<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span> PRIVATE PocoFoundationd)<br></code></pre></td></tr></table></figure><p>编译和运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> build &amp;&amp; <span class="hljs-built_in">cd</span> build<br>cmake ..<br>cmake --build .<br>./Debug/PocoDemo.exe<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">ServerApp</span>::<span class="hljs-function"><span class="hljs-title">initialize</span>()</span><br><span class="hljs-variable">ServerApp</span>::<span class="hljs-function"><span class="hljs-title">main</span>()</span><br><span class="hljs-variable">ServerApp</span>::<span class="hljs-function"><span class="hljs-title">uninitialize</span>()</span><br></code></pre></td></tr></table></figure><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><p><a href="https://github.com/tthres/PocoDemo">https://github.com/tthres/PocoDemo</a></p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cmake指定编译器版本问题解决</title>
    <link href="/2023/09/02/2023-9-2-cmake%E6%8C%87%E5%AE%9A%E7%BC%96%E8%AF%91%E5%99%A8%E7%89%88%E6%9C%AC%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    <url>/2023/09/02/2023-9-2-cmake%E6%8C%87%E5%AE%9A%E7%BC%96%E8%AF%91%E5%99%A8%E7%89%88%E6%9C%AC%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在Windows中有一些库由于历史原因需要使用Visual Studio 14 2015才能与程序链接编译成功，所以在cmake构建是执行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt;cmake .. -G <span class="hljs-string">&quot;Visual Studio 14 2015&quot;</span> -A win32<br></code></pre></td></tr></table></figure><p>在此之前已经在visual studio installer（2022）中下载了各个版本的C++工具集和相关组件。但还是出现问题：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs bash">-- Selecting Windows SDK version  to target Windows 10.0.22621.<br>CMake Error at CMakeLists.txt:3 (project):<br>  Failed to run MSBuild <span class="hljs-built_in">command</span>:<br><br>    C:/Program Files (x86)/MSBuild/14.0/bin/MSBuild.exe<br><br>  to get the value of VCTargetsPath:<br><br>    Microsoft (R) 生成引擎版本 14.0.23107.0<br>    版权所有(C) Microsoft Corporation。保留所有权利。<br><br>    生成启动时间为 2023/8/31 9:06:39。<br>    节点 1 上的项目“E:XXX\build\CMakeFiles\3.27.0\VCTargetsPath.vcxproj”(默认 目标)。<br>    E:XXX\build\CMakeFiles\3.27.0\VCTargetsPath.vcxproj(14,2): error MSB4019: 未找到导入的项目“E:\Microsoft.Cpp.Default.props”。请确认 &lt;Import&gt; 声明中的路径正确，且磁盘上存在该文件。<br>    已完成生成项目“E:XXX\build\CMakeFiles\3.27.0\VCTargetsPath.vcxproj”(默认目标)的操作 - 失败。<br><br>    生成失败。<br><br>    “E:XXX\build\CMakeFiles\3.27.0\VCTargetsPath.vcxproj”(默认目标) (1) -&gt;<br>      E:XXX\build\CMakeFiles\3.27.0\VCTargetsPath.vcxproj(14,2): error MSB4019: 未找到导入的项目“E:\Microsoft.Cpp.Default.props”。请确认 &lt;Import&gt; 声明中的路径正确，且磁盘上存在该文件。<br><br>        0 个警告<br>        1 个错误<br><br>    已用时间 00:00:00.01<br><br><br>  Exit code: 1<br><br><br><br>-- Configuring incomplete, errors occurred!<br></code></pre></td></tr></table></figure><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><ul><li><strong>检查MSBuild.exe是否存在</strong>查看报错，发现是未能执行<code>C:/Program Files (x86)/MSBuild/14.0/bin/MSBuild.exe</code>，检查路径确实存在改文件，当安装了相应的SDK后文件就会默认安装到这个目录。</li><li><strong>环境变量检查</strong>确保<code>VCTargetsPath</code>环境变量已被正确设置。使用Everything搜了一下发现<code>Microsoft.Cpp.Default.props</code> 确实不在E盘而是在C盘，它的路径应该是被重写了，可以手动为当前会话设置它。例如：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">set</span> VCTargetsPath=C:\Program Files (x86)\MSBuild\Microsoft.Cpp\v4.0\V140<br></code></pre></td></tr></table></figure>设置后发现问题解决了。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个问题的出现可能是由于一下几个原因：</p><ul><li><strong>安装顺序</strong>先安装了cmake再安装VS</li><li><strong>多版本visual studio</strong>装了很多版本的编译器，可能环境变量一直被改动</li></ul>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cmake</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>std::string作为函数返回值</title>
    <link href="/2023/03/19/2023-3-19-std-string%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC/"/>
    <url>/2023/03/19/2023-3-19-std-string%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<p>在使用std::string时，需要注意std::string的内存拷贝和释放时的问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassBug</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">const</span> std::string <span class="hljs-title">StringToUpper</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* src)</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::string temp;<br>        temp = src;<br>        std::<span class="hljs-built_in">transform</span>(temp.<span class="hljs-built_in">begin</span>(), temp.<span class="hljs-built_in">end</span>(), temp.<span class="hljs-built_in">begin</span>(), ::toupper);<br>        <span class="hljs-keyword">return</span> temp;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">const</span> std::string <span class="hljs-title">StringToLower</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* src)</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::string temp;<br>        temp = src;<br>        std::<span class="hljs-built_in">transform</span>(temp.<span class="hljs-built_in">begin</span>(), temp.<span class="hljs-built_in">end</span>(), temp.<span class="hljs-built_in">begin</span>(), ::tolower);<br>        <span class="hljs-keyword">return</span> temp;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ClassBug</span>() &#123;&#125;<br>    ~<span class="hljs-built_in">ClassBug</span>() &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FixTest</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;       <br>            <span class="hljs-type">const</span> <span class="hljs-type">char</span>* test = <span class="hljs-string">&quot;ABCddasdasdaddaweqWADfFcddasdasdaddaweqewabcddasdasdaddaweWQD&quot;</span>;<br>            <span class="hljs-type">const</span> <span class="hljs-type">char</span>* test1 = <span class="hljs-built_in">StringToUpper</span>(test).<span class="hljs-built_in">c_str</span>();<br><br>            <span class="hljs-type">const</span> <span class="hljs-type">char</span>* test2 = <span class="hljs-built_in">StringToLower</span>(test).<span class="hljs-built_in">c_str</span>();<br>            std::cout &lt;&lt; test &lt;&lt; std::endl;<br>            std::cout &lt;&lt; test1 &lt;&lt; std::endl;<br>            std::cout &lt;&lt; test2 &lt;&lt; std::endl;<br>        <br>    &#125;<br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    &#123;<br>        ClassBug bug;<br>        bug.<span class="hljs-built_in">FixTest</span>();<br>    &#125;<br>    <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码在g++编译下会出现如下警告：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">main.cpp:<span class="hljs-number">40</span>:<span class="hljs-number">33</span>: warning: <span class="hljs-keyword">object</span> backing the pointer will be destroyed at the <span class="hljs-keyword">end</span> <span class="hljs-keyword">of</span> the full-expression <span class="hljs-literal">[-W<span class="hljs-identifier">dangling</span>-<span class="hljs-identifier">gsl</span>]</span><br>            const <span class="hljs-built_in">char</span>* test1 = <span class="hljs-constructor">StringToUpper(<span class="hljs-params">test</span>)</span>.c<span class="hljs-constructor">_str()</span>;<br>                                ^~~~~~~~~~~~~~~~~~~<br>main.cpp:<span class="hljs-number">41</span>:<span class="hljs-number">33</span>: warning: <span class="hljs-keyword">object</span> backing the pointer will be destroyed at the <span class="hljs-keyword">end</span> <span class="hljs-keyword">of</span> the full-expression <span class="hljs-literal">[-W<span class="hljs-identifier">dangling</span>-<span class="hljs-identifier">gsl</span>]</span><br>            const <span class="hljs-built_in">char</span>* test2 = <span class="hljs-constructor">StringToLower(<span class="hljs-params">test</span>)</span>.c<span class="hljs-constructor">_str()</span>;<br>                                ^~~~~~~~~~~~~~~~~~~<br></code></pre></td></tr></table></figure><p>输出的结果也有问题：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ABCddasdasdaddaweqWADfFcddasdasdaddaweqewabcddasdasdaddaweWQD</span><br><span class="hljs-attribute">abcddasdasdaddaweqwadffcddasdasdaddaweqewabcddasdasdaddawewqd</span><br><span class="hljs-attribute">abcddasdasdaddaweqwadffcddasdasdaddaweqewabcddasdasdaddawewqd</span><br></code></pre></td></tr></table></figure><p>而在visual studio下则会出现乱码：<br><img src="/img/2023-3-19-string%E4%BD%9C%E4%B8%BA%E8%BF%94%E5%9B%9E%E5%80%BC/1.png" alt="1"></p><p>原因在于这两行代码中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* test1 = <span class="hljs-built_in">StringToUpper</span>(test).<span class="hljs-built_in">c_str</span>();<br><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* test2 = <span class="hljs-built_in">StringToLower</span>(test).<span class="hljs-built_in">c_str</span>();<br></code></pre></td></tr></table></figure><p>g++警告提示 test1 指向的内存将在当前表达式结束时被销毁，这可能导致悬挂指针，也就是指向已经释放的内存。这是因为 StringToUpper(test) 返回一个 std::string 对象，它在表达式结束时将被销毁，而 test1 指向该对象的内部缓冲区，因此 test1 将指向一个已经释放的内存。<br><br>可以看看std::string的源码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">A string looks like <span class="hljs-keyword">this</span>:<br>*<br>*  @code<br>*                                        [_Rep]<br>*                                        _M_length<br>*   [__rc_string_base&lt;char_type&gt;]        _M_capacity<br>*   _M_dataplus                          _M_refcount<br>*   _M_p ----------------&gt;               unnamed array of char_type<br>*  @endcode<br>*<br></code></pre></td></tr></table></figure><p>其中_M_p指向字符串中的第一个字符，当执行”StringToUpper(test).c_str()”后，指针所指向的空间将会被释放。<br>为了解决这个问题，可以将 StringToUpper 函数返回 std::string 对象，而不是将其转换为 C 风格字符串并返回指针。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为什么要pair&lt;const string, ...&gt;?</title>
    <link href="/2022/11/11/2022-11-10-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81pair-const-string/"/>
    <url>/2022/11/11/2022-11-10-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81pair-const-string/</url>
    
    <content type="html"><![CDATA[<p>由于隐式类型转换，当常量引用的类型和实际引用的对象类型不同时，可能会产生一个临时对象，造成不必要的开销，同时也会造成临时对象释放导致的空指针问题。  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    map&lt;string, <span class="hljs-type">int</span>&gt; _map = &#123;<br>        &#123;<span class="hljs-string">&quot;cute&quot;</span>, <span class="hljs-number">1</span>&#125;, <br>        &#123;<span class="hljs-string">&quot;fish&quot;</span>, <span class="hljs-number">2</span>&#125;, <br>        &#123;<span class="hljs-string">&quot;os&quot;</span>, <span class="hljs-number">3</span>&#125;<br>    &#125;;<br>    <span class="hljs-keyword">for</span> (pair&lt;string, <span class="hljs-type">int</span>&gt; &amp;t : _map) &#123;<br>        <br>        cout &lt;&lt; t.second &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">error: invalid initialization of reference of type ‘std::pair&lt;std::__cxx11::basic_string&lt;<span class="hljs-type">char</span>&gt;, <span class="hljs-type">int</span>&gt;&amp;’ from expression of type ‘std::pair&lt;<span class="hljs-type">const</span> std::__cxx11::basic_string&lt;<span class="hljs-type">char</span>&gt;, <span class="hljs-type">int</span>&gt;’<br>   <span class="hljs-number">11</span> |     <span class="hljs-keyword">for</span> (pair&lt;string, <span class="hljs-type">int</span>&gt; &amp;t : _map) &#123;<br>      |                                 ^~~~<br></code></pre></td></tr></table></figure><p>改成这样就可以了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">pair&lt;<span class="hljs-type">const</span> string, <span class="hljs-type">int</span>&gt; &amp;t : _map<br></code></pre></td></tr></table></figure><p>也可以用map::value_type或者auto。<br>遍历map的pair是属于自定义的类型，与*_map.begin()类型不一致，引用的就全变成临时变量了，临时变量自然要加上const。 (<a href="https://tthres.github.io/2022/08/07/2022-8-7-C-const/">https://tthres.github.io/2022/08/07/2022-8-7-C-const/</a>)  这里有介绍const。每创建一个临时对象都会牵扯到内存的分配与回收，这种开销是不应忽视的。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言提取RTP载荷</title>
    <link href="/2022/09/26/2022-9-26-C%E8%AF%AD%E8%A8%80%E6%8F%90%E5%8F%96RTP%E8%BD%BD%E8%8D%B7/"/>
    <url>/2022/09/26/2022-9-26-C%E8%AF%AD%E8%A8%80%E6%8F%90%E5%8F%96RTP%E8%BD%BD%E8%8D%B7/</url>
    
    <content type="html"><![CDATA[<h1 id="RTP头结构"><a href="#RTP头结构" class="headerlink" title="RTP头结构"></a>RTP头结构</h1><br/><br/><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">0                    1                    2                    3</span><br><span class="hljs-section">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="hljs-section">|V=2|P|X|  CC   |M|     PT      |       sequence number         |</span><br><span class="hljs-section">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="hljs-section">|                           timestamp                           |</span><br><span class="hljs-section">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="hljs-section">|           synchronization source (SSRC) identifier            |</span><br><span class="hljs-section">+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+</span><br>|            contributing source (CSRC) identifiers             |<br><span class="hljs-section">|                             ....                              |</span><br><span class="hljs-section">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></code></pre></td></tr></table></figure><p>提取载荷只需要将RTP包头的各个标志位解析出来即可。  </p><h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><p>RTP包头结构分别有大端和小端，默认为小端</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">rtp_header</span> &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> __BYTE_ORDER == __BIG_ENDIA</span><br>    <span class="hljs-type">uint16_t</span> version:<span class="hljs-number">2</span>;<br><span class="hljs-type">uint16_t</span> padding:<span class="hljs-number">1</span>;<br><span class="hljs-type">uint16_t</span> extension:<span class="hljs-number">1</span>;<br><span class="hljs-type">uint16_t</span> csrc_count:<span class="hljs-number">4</span>;<br><span class="hljs-type">uint16_t</span> marker_bit:<span class="hljs-number">1</span>;<br><span class="hljs-type">uint16_t</span> type:<span class="hljs-number">7</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> __BYTE_ORDER == __LITTLE_ENDIAN</span><br>    <span class="hljs-type">uint16_t</span> csrc_count:<span class="hljs-number">4</span>;<br>    <span class="hljs-type">uint16_t</span> extension:<span class="hljs-number">1</span>;<br>    <span class="hljs-type">uint16_t</span> padding:<span class="hljs-number">1</span>;<br>    <span class="hljs-type">uint16_t</span> version:<span class="hljs-number">2</span>;<br>    <span class="hljs-type">uint16_t</span> type:<span class="hljs-number">7</span>;<br>    <span class="hljs-type">uint16_t</span> marker_bit:<span class="hljs-number">1</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-type">uint16_t</span> seq_number;<br>    <span class="hljs-type">uint32_t</span> timestamp;<br>    <span class="hljs-type">uint32_t</span> ssrc;<br>    <span class="hljs-type">uint32_t</span> csrc[<span class="hljs-number">16</span>];<br>&#125; rtp_header;<br></code></pre></td></tr></table></figure><br/>RTP拓展报头：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">rtp_header_extension</span> &#123;<br>    <span class="hljs-type">uint16_t</span> type;<br>    <span class="hljs-type">uint16_t</span> length;<br>&#125; rtp_header_extension;<br></code></pre></td></tr></table></figure><h1 id="解析方法"><a href="#解析方法" class="headerlink" title="解析方法"></a>解析方法</h1><p>定义提取载荷函数，传入参数为：包的起始位置（<em>buf），包的长度（len），传入传出参数：rtp载荷的长度（payload_len）。<br>1、判断包的长度是否大于12个字节，RTP包头的长度至少为12字节。<br>2、判断CSRC计数器，如果有则包头长度seek += csrc_count</em>4。<br>3、判断X，是否含有拓展报头，如果有继续加长RTP包头长度seek。<br>4、判断填充位P，如果P=1，则在该报文的尾部填充一个或多个额外的八位组，它们不是有效载荷的一部分。<br>5、最后返回RTP载荷的起始位置指针。</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">uint8_t</span> *<span class="hljs-title">rtp_payload</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> *buf, <span class="hljs-type">int</span> len, <span class="hljs-type">int</span> *payload_len)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(!buf || len &lt; <span class="hljs-number">12</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    rtp_header *rtp = (rtp_header *) buf;<br>    <span class="hljs-keyword">if</span>(rtp-&gt;version != <span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> seek = <span class="hljs-number">12</span>;<br>    <span class="hljs-keyword">if</span>(rtp-&gt;csrc_count)&#123;<br>        seek += rtp-&gt;csrc_count*<span class="hljs-number">4</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(rtp-&gt;extension)&#123;<br>        rtp_header_extension *ext = (rtp_header_extension *) (buf + seek);<br>        <span class="hljs-type">int</span> ext_len = <span class="hljs-built_in">ntohs</span>(ext-&gt;length) * <span class="hljs-number">4</span>;<br>        seek += <span class="hljs-number">4</span>;<br><br>        <span class="hljs-keyword">if</span>(len &gt; (seek + ext_len))&#123;<br>            seek += ext_len;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> padding_len = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(rtp-&gt;padding)&#123;<br>        padding_len = buf[len<span class="hljs-number">-1</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(len - seek - padding_len &lt;= <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(payload_len)&#123;<br>        *payload_len = len - seek - padding_len;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> buf + seek;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>视频质量诊断</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>右值引用</title>
    <link href="/2022/09/13/2022-9-12-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"/>
    <url>/2022/09/13/2022-9-12-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="右值"><a href="#右值" class="headerlink" title="右值"></a>右值</h1><p>左值表示的是常态，右值表示临时，如果一个表达式能放到运算符的左边，它就是左值。<br>如果一个函数的传入参数为左值，它会优先绑定函数的左值引用版本，反之优先绑定右值引用的版本：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;a)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;left value&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;&amp;a)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;right value&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;   <br>    <span class="hljs-type">int</span> n = <span class="hljs-number">1</span>; <br>    <span class="hljs-built_in">judge</span>(n);            <br>    <span class="hljs-built_in">judge</span>(n + <span class="hljs-number">1</span>);  <br>    <span class="hljs-built_in">judge</span>(n++);      <br>    <span class="hljs-built_in">judge</span>(++n);      <br>    <span class="hljs-built_in">judge</span>(<span class="hljs-number">1</span> + <span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">judge</span>(n += <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs coq"><span class="hljs-built_in">left</span> value<br><span class="hljs-built_in">right</span> value<br><span class="hljs-built_in">right</span> value<br><span class="hljs-built_in">left</span> value<br><span class="hljs-built_in">right</span> value<br><span class="hljs-built_in">left</span> value<br></code></pre></td></tr></table></figure><br/><p>看下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">judge2</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;a)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;left value --judge2 --&quot;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">judge2</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;&amp;a)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;right value --judge2 --&quot;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;a)</span> </span>&#123;<br>    <span class="hljs-built_in">judge2</span>(a);<br>    cout &lt;&lt; <span class="hljs-string">&quot;left value&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;&amp;a)</span> </span>&#123;<br>    <span class="hljs-built_in">judge2</span>(a);<br>    cout &lt;&lt; <span class="hljs-string">&quot;right value&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;   <br>    <span class="hljs-type">int</span> n = <span class="hljs-number">123</span>;<br>    <span class="hljs-built_in">judge</span>(n);<br>    <span class="hljs-built_in">judge</span>(n + <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">judge</span>(n++);<br>    <span class="hljs-built_in">judge</span>(++n);<br>    <span class="hljs-built_in">judge</span>(<span class="hljs-number">1</span> + <span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">judge</span>(n += <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">left</span> value <span class="hljs-attr">--judge2</span> <span class="hljs-attr">--left</span> value<br><span class="hljs-attribute">left</span> value <span class="hljs-attr">--judge2</span> <span class="hljs-attr">--right</span> value<br><span class="hljs-attribute">left</span> value <span class="hljs-attr">--judge2</span> <span class="hljs-attr">--right</span> value<br><span class="hljs-attribute">left</span> value <span class="hljs-attr">--judge2</span> <span class="hljs-attr">--left</span> value<br><span class="hljs-attribute">left</span> value <span class="hljs-attr">--judge2</span> <span class="hljs-attr">--right</span> value<br><span class="hljs-attribute">left</span> value <span class="hljs-attr">--judge2</span> <span class="hljs-attr">--left</span> value<br></code></pre></td></tr></table></figure><p>可以看到当出现嵌套调用后，judeg2全部输出为左值调用了。这是因为判断是否是左值可以根据代码到下一行时能否根据单一变量访问到；在上面的例子中，如果能够 judge2(x) 的下一行代码访问 x ，说明 x 是一个左值，这就导致嵌套调用的judge2不能区分出左右值。  </p><p>嵌套调用会出现右值变左值的情况，在开发中可能会造成不好的影响，可以使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::<span class="hljs-built_in">move</span>(a);           <span class="hljs-comment">// move可以直接变成右值</span><br><br>std::forward&lt;<span class="hljs-type">int</span> &amp;&amp;&gt;(a);<span class="hljs-comment">// forward&lt;&gt;()可以把变量变成任意类型</span><br></code></pre></td></tr></table></figure><h1 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> &amp;a = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>上面的代码无法通过编译，因为定义引用变量，需要取右边“1”的地址进行存储，但是1是立即数字，没有在内存上存储，因此是无法取地址的。<br>可以通过下面的操作使编译通过：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;a = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>这个操作是在内存上产生了一个临时量保存了1，a现在引用的是这个临时量，相对于下面的操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">这里temp是在内存上产生的临时量</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> temp = <span class="hljs-number">1</span>; <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;a = temp;<br></code></pre></td></tr></table></figure><br/><p>左值引用要求右边的值必须能够取地址，如果无法取地址，可以用常引用，但会造成无法修改数据。可以使用右值引用来解决：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> &amp;&amp;a = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>有地址的用左值引用，没有地址的用右值引用；有变量名字的用左值引用，没有变量名字的（比如临时量没有名字）用右值引用。<br>C++定义左值和右值是为了分情况处理。有时用右值能减少开销。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++实现队列和优先队列</title>
    <link href="/2022/09/12/2022-9-12-C-%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%E5%92%8C%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    <url>/2022/09/12/2022-9-12-C-%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%E5%92%8C%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="实现队列和优先队列"><a href="#实现队列和优先队列" class="headerlink" title="实现队列和优先队列"></a>实现队列和优先队列</h1><p>要实现两种队列，可以创建一个队列类，派生类可以继承以实现不同种类的队列。需要包含以下的接口：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">IQueue</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>   </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span>         </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span>  <span class="hljs-title">top</span><span class="hljs-params">()</span>   <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span>  <span class="hljs-title">front</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span>  <span class="hljs-title">size</span><span class="hljs-params">()</span>  <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">IQueue</span>() &#123;&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">queue</span> : <span class="hljs-keyword">public</span> IQueue &#123;&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">priority_queue</span> : <span class="hljs-keyword">public</span> IQueue &#123;&#125;;<br></code></pre></td></tr></table></figure><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>对于普通队列，成员属性需要包含存储数据的数据区指针*data，头元素和位元素的位置head、tail,队列中元素数量count， 队列的大小size。  </p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>开辟存储空间，将队列各个成员属性初始化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">queue</span>(<span class="hljs-type">int</span> n = <span class="hljs-number">10</span>) : <span class="hljs-built_in">data</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n]), <span class="hljs-built_in">head</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">tail</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">count</span>(<span class="hljs-number">0</span>), __size(n) &#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="push"><a href="#push" class="headerlink" title="push()"></a>push()</h3><p>当队列中的元素count等于队列的大小size时，先对队列进行扩容；扩容完成后将新的元素放到队列的末尾。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> <span class="hljs-keyword">override</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (count == __size) <span class="hljs-built_in">expand</span>();<br>    data[tail++] = val;<br>    tail %= __size;<br>    count += <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><p>为了方便后续操作，将存储区的第一个元素的编号从0改为1，成员属性加上一个raw_data表示存储区，data指向raw_data的-1的位置，这样data[1]就是第一个元素。  </p><h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>优先队列可以看成完全二叉树，完全二叉树的定义：对于一个树高为h的二叉树，如果其第0层至第h-1层的节点都满。如果最下面一层节点不满，则所有的节点在左边的连续排列，空位都在右边。这样的二叉树就是一棵完全二叉树。<br>设根节点编号为1；则对任意节点，其左孩子的编号为2 * i，右孩子编号为2 * i + 1（i为当前节点的编号）。</p><h3 id="push-1"><a href="#push-1" class="headerlink" title="push()"></a>push()</h3><p>添加元素相比普通队列需要新加一个调整的操作，由于新加的元素在底部，所以将调整称为向上调整。</p><h3 id="pop"><a href="#pop" class="headerlink" title="pop()"></a>pop()</h3><p>删除队列头的元素后需要将队尾元素覆盖到队头，由于减少的元素在队头，所以要进行向下调整。</p><h3 id="添加和删除调整"><a href="#添加和删除调整" class="headerlink" title="添加和删除调整"></a>添加和删除调整</h3><h4 id="添加调整"><a href="#添加调整" class="headerlink" title="添加调整"></a>添加调整</h4><p>传入的参数为需要调整的元素的下标，比较当前节点和它父节点的值，如果当前节点大于父节点，交换两个节点，再继续递归调整：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">up_maintain</span><span class="hljs-params">(<span class="hljs-type">int</span> ind)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (ind == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> ;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">cmp</span>(data[ind &gt;&gt; <span class="hljs-number">1</span>], data[ind])) &#123;<br>        <span class="hljs-built_in">swap</span>(data[ind], data[ind &gt;&gt; <span class="hljs-number">1</span>]);<br>        <span class="hljs-built_in">up_maintain</span>(ind &gt;&gt; <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="删除调整"><a href="#删除调整" class="headerlink" title="删除调整"></a>删除调整</h4><p>cmp为自定义比较规则</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">down_maintain</span><span class="hljs-params">(<span class="hljs-type">int</span> ind)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> ((ind &lt;&lt; <span class="hljs-number">1</span>) &gt; count) <span class="hljs-keyword">return</span> ;<span class="hljs-comment">// 说明它没有子节点</span><br>    <span class="hljs-type">int</span> temp = ind;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">cmp</span>(data[temp], data[ind &lt;&lt; <span class="hljs-number">1</span>])) temp = ind &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// 如果ind小于左子树，则将ind指向左孩子的坐标</span><br>    <span class="hljs-comment">// 如果右子树的坐标 《 count且temp的值小于右子树的坐标</span><br>    <span class="hljs-keyword">if</span> ((ind &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>) &lt;= count &amp;&amp; <span class="hljs-built_in">cmp</span>(data[temp], data[ind &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>])) temp = ind &gt;&gt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 此时temp已经指向了三个节点中的最小值</span><br>    <span class="hljs-keyword">if</span> (temp == ind) <span class="hljs-keyword">return</span> ;<br>    <span class="hljs-built_in">swap</span>(data[temp], data[ind]);<br>    <span class="hljs-built_in">down_maintain</span>(temp);<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-comment">//#include &lt;queue&gt;</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">IQueue</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">front</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">IQueue</span>() &#123;&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">queue</span> : <span class="hljs-keyword">public</span> IQueue &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> *data;<br>    <span class="hljs-type">int</span> head, tail, count, __size;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">expand</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-function">queue <span class="hljs-title">q</span><span class="hljs-params">(<span class="hljs-number">2</span> * __size)</span></span>;<br>        <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">empty</span>()) &#123;<br>            q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">front</span>());<br>            <span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">this</span>-&gt;__swap(q); <span class="hljs-comment">// 交换当前队列与q的信息,这样当退出这个函数时，原来较小队列就会被回收</span><br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">queue</span>(<span class="hljs-type">int</span> n = <span class="hljs-number">10</span>) : <span class="hljs-built_in">data</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n]), <span class="hljs-built_in">head</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">tail</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">count</span>(<span class="hljs-number">0</span>), __size(n) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> <span class="hljs-keyword">override</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (count == __size) <span class="hljs-built_in">expand</span>();<br>        data[tail++] = val;<br>        tail %= __size;<br>        count += <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> ;<br>        head += <span class="hljs-number">1</span>;<br>        head %= __size;<br>        count -= <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span>&#123; <span class="hljs-keyword">return</span> count == <span class="hljs-number">0</span>; &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span>&#123; <span class="hljs-keyword">return</span> data[head]; &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">front</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span>&#123; <span class="hljs-keyword">return</span> data[head]; &#125; <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span>&#123; <span class="hljs-keyword">return</span> count; &#125;<br>    <span class="hljs-type">void</span> __swap(queue &amp;q) &#123;<br>        <span class="hljs-built_in">swap</span>(<span class="hljs-keyword">this</span>-&gt;data, q.data);<br>        <span class="hljs-built_in">swap</span>(<span class="hljs-keyword">this</span>-&gt;head, q.head);<br>        <span class="hljs-built_in">swap</span>(<span class="hljs-keyword">this</span>-&gt;tail, q.tail);<br>        <span class="hljs-built_in">swap</span>(<span class="hljs-keyword">this</span>-&gt;count, q.count);<br>        <span class="hljs-built_in">swap</span>(<span class="hljs-keyword">this</span>-&gt;__size, q.__size);<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    ~<span class="hljs-built_in">queue</span>() &#123;<br>        <span class="hljs-keyword">if</span> (data) <span class="hljs-keyword">delete</span>[] data;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">priority_queue</span> : <span class="hljs-keyword">public</span> IQueue &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> *raw_data;<br>    <span class="hljs-type">int</span> *data;<br>    <span class="hljs-type">int</span> count, __size;<br>    function&lt;<span class="hljs-type">bool</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; cmp;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">expand</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-function">priority_queue <span class="hljs-title">q</span><span class="hljs-params">(<span class="hljs-number">2</span> * __size)</span></span>;<br>        <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">empty</span>()) &#123;<br>            q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">front</span>());<br>            <span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">this</span>-&gt;__swap(q); <span class="hljs-comment">// 交换当前队列与q的信息,这样当退出这个函数时，原来较小队列就会被回收</span><br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-comment">// 向上调整：</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">up_maintain</span><span class="hljs-params">(<span class="hljs-type">int</span> ind)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (ind == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">cmp</span>(data[ind &gt;&gt; <span class="hljs-number">1</span>], data[ind])) &#123;<br>            <span class="hljs-built_in">swap</span>(data[ind], data[ind &gt;&gt; <span class="hljs-number">1</span>]);<br>            <span class="hljs-built_in">up_maintain</span>(ind &gt;&gt; <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-comment">// 向下调整：</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">down_maintain</span><span class="hljs-params">(<span class="hljs-type">int</span> ind)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> ((ind &lt;&lt; <span class="hljs-number">1</span>) &gt; count) <span class="hljs-keyword">return</span> ;<span class="hljs-comment">// 说明它没有子节点</span><br>        <span class="hljs-type">int</span> temp = ind;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">cmp</span>(data[temp], data[ind &lt;&lt; <span class="hljs-number">1</span>])) temp = ind &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// 如果ind小于左子树，则将ind指向左孩子的坐标</span><br>        <span class="hljs-comment">// 如果右子树的坐标 《 count且temp的值小于右子树的坐标</span><br>        <span class="hljs-keyword">if</span> ((ind &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>) &lt;= count &amp;&amp; <span class="hljs-built_in">cmp</span>(data[temp], data[ind &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>])) temp = ind &gt;&gt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (temp == ind) <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-built_in">swap</span>(data[temp], data[ind]);<br>        <span class="hljs-built_in">down_maintain</span>(temp);<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">priority_queue</span>(<span class="hljs-type">int</span> n = <span class="hljs-number">10</span>, function&lt;<span class="hljs-built_in">bool</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; cmp = <span class="hljs-built_in">less</span>&lt;<span class="hljs-type">int</span>&gt;()) <br>    : <span class="hljs-built_in">raw_data</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n]), <span class="hljs-built_in">data</span>(raw_data - <span class="hljs-number">1</span>), <span class="hljs-built_in">count</span>(<span class="hljs-number">0</span>), __size(n), <span class="hljs-built_in">cmp</span>(cmp) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> <span class="hljs-keyword">override</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (count == __size) <span class="hljs-built_in">expand</span>();<br>        count += <span class="hljs-number">1</span>;<br>        data[count] = val;<br>        <span class="hljs-built_in">up_maintain</span>(count);<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> ;<br>        data[<span class="hljs-number">1</span>] = data[count];<br>        count -= <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">down_maintain</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span>&#123; <span class="hljs-keyword">return</span> count == <span class="hljs-number">0</span>; &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span>&#123; <span class="hljs-keyword">return</span> data[<span class="hljs-number">1</span>]; &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">front</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span>&#123; <span class="hljs-keyword">return</span> data[<span class="hljs-number">1</span>]; &#125; <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span>&#123; <span class="hljs-keyword">return</span> count; &#125;<br>    <span class="hljs-type">void</span> __swap(priority_queue &amp;q) &#123;<br>        <span class="hljs-built_in">swap</span>(<span class="hljs-keyword">this</span>-&gt;raw_data, q.raw_data);<br>        <span class="hljs-built_in">swap</span>(<span class="hljs-keyword">this</span>-&gt;data, q.data);<br>        <span class="hljs-built_in">swap</span>(<span class="hljs-keyword">this</span>-&gt;count, q.count);<br>        <span class="hljs-built_in">swap</span>(<span class="hljs-keyword">this</span>-&gt;__size, q.__size);<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    ~<span class="hljs-built_in">priority_queue</span>() &#123;<br>        <span class="hljs-keyword">if</span> (raw_data) <span class="hljs-keyword">delete</span>[] raw_data;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;   <br>    priority_queue q;<br>    q.<span class="hljs-built_in">push</span>(<span class="hljs-number">3</span>);<br>    q.<span class="hljs-built_in">push</span>(<span class="hljs-number">5</span>);<br>    q.<span class="hljs-built_in">push</span>(<span class="hljs-number">6</span>);<br>    q.<span class="hljs-built_in">push</span>(<span class="hljs-number">7</span>);<br>    cout &lt;&lt; q.<span class="hljs-built_in">top</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>shared_from_this解决的问题</title>
    <link href="/2022/09/05/2022-9-05-shared-from-this/"/>
    <url>/2022/09/05/2022-9-05-shared-from-this/</url>
    
    <content type="html"><![CDATA[<h1 id="智能指针使用时的问题"><a href="#智能指针使用时的问题" class="headerlink" title="智能指针使用时的问题"></a>智能指针使用时的问题</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>():<span class="hljs-built_in">mptr</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>) <br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;A()&quot;</span> &lt;&lt; endl;<br>&#125;<br>~<span class="hljs-built_in">A</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;~A()&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">delete</span> mptr; <br>mptr = <span class="hljs-literal">nullptr</span>;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> *mptr;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>A *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">A</span>(); <br><br><span class="hljs-function">shared_ptr&lt;A&gt; <span class="hljs-title">ptr1</span><span class="hljs-params">(p)</span></span>; <span class="hljs-comment">// 用shared_ptr智能指针管理指针p指向的对象</span><br><span class="hljs-function">shared_ptr&lt;A&gt; <span class="hljs-title">ptr2</span><span class="hljs-params">(p)</span></span>; <span class="hljs-comment">// 用shared_ptr智能指针管理指针p指向的对象</span><br><br>cout &lt;&lt; ptr1.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl; <br>cout &lt;&lt; ptr2.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">A</span><span class="hljs-params">()</span></span><br><span class="hljs-number">1</span><br><span class="hljs-number">1</span><br>~<span class="hljs-built_in">A</span>()<br>~<span class="hljs-built_in">A</span>()<br></code></pre></td></tr></table></figure><p>当用智能指针shared_ptr智能指针管理指针p指向的对象时，两个指针应该管理的是同一个资源，但是引用计数只有1，导致A对象析构了两次。</p><h1 id="shared-ptr原理"><a href="#shared-ptr原理" class="headerlink" title="shared_ptr原理"></a>shared_ptr原理</h1><p>shared_ptr定义:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Ty</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">shared_ptr</span><br>: <span class="hljs-keyword">public</span> _Ptr_base&lt;_Ty&gt;     <span class="hljs-comment">// 继承自_Ptr_base</span><br></code></pre></td></tr></table></figure><br/><p>_Ptr_base源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Ty</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">_Ptr_base</span><br>&#123;<span class="hljs-comment">// base class for shared_ptr and weak_ptr</span><br><span class="hljs-keyword">protected</span>:<br><span class="hljs-type">void</span> _Decref()<br>&#123;<span class="hljs-comment">// decrement reference count</span><br><span class="hljs-keyword">if</span> (_Rep)<br>&#123;<br>_Rep-&gt;_Decref();<br>&#125;<br>&#125;<br><br><span class="hljs-type">void</span> _Decwref()<br>&#123;<span class="hljs-comment">// decrement weak reference count</span><br><span class="hljs-keyword">if</span> (_Rep)<br>&#123;<br>_Rep-&gt;_Decwref();<br>&#125;<br>&#125;<br><span class="hljs-keyword">private</span>:<br>element_type * _Ptr&#123;<span class="hljs-literal">nullptr</span>&#125;;       <span class="hljs-comment">// 指向资源的指针</span><br>_Ref_count_base * _Rep&#123;<span class="hljs-literal">nullptr</span>&#125;;    <span class="hljs-comment">// 指向资源引用计数的指针</span><br>&#125;;<br></code></pre></td></tr></table></figure><br/><p>在_Ref_count_base中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">__declspec</span>(novtable) _Ref_count_base<br>&#123;<span class="hljs-comment">// common code for reference counting</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">/* _Uses记录了资源的引用计数，也就是引用资源的shared_ptr</span><br><span class="hljs-comment">的个数；_Weaks记录了weak_ptr的个数，相当于资源观察者的</span><br><span class="hljs-comment">个数，都是定义成基于CAS操作的原子类型，增减引用计数时是</span><br><span class="hljs-comment">线程安全的操作</span><br><span class="hljs-comment">*/</span><br>_Atomic_counter_t _Uses;<br>_Atomic_counter_t _Weaks;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以，一个shared_ptr对象有两个指针element_type和_Ref_count_base分别指向堆上的实际对象和引用计数。当我们使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<br><span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ptr1</span><span class="hljs-params">(p)</span></span>;<br><span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ptr2</span><span class="hljs-params">(p)</span></span>;<br>cout&lt;&lt;ptr1.<span class="hljs-built_in">use_count</span>()&lt;&lt;endl;<br>cout&lt;&lt;ptr2.<span class="hljs-built_in">use_count</span>()&lt;&lt;endl;<br></code></pre></td></tr></table></figure><p>shared_ptr ptr1( p )和shared_ptr ptr2( p )都调用了shared_ptr的构造函数，在它的构造函数中，都重新开辟了引用计数的资源，导致ptr1和ptr2都记录了一次new int的引用计数，都是1，析构的时候它俩都去释放内存资源，导致释放逻辑错误。<br>如果要避免上面的错误，就不能再调用构造函数了，应该用拷贝构造：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>A *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">A</span>(); <br><br><span class="hljs-function">shared_ptr&lt;A&gt; <span class="hljs-title">ptr1</span><span class="hljs-params">(p)</span></span>;<br><span class="hljs-function">shared_ptr&lt;A&gt; <span class="hljs-title">ptr2</span><span class="hljs-params">(ptr1)</span></span>;<br><br>cout &lt;&lt; ptr1.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl; <br>cout &lt;&lt; ptr2.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">A</span><span class="hljs-params">()</span></span><br><span class="hljs-number">2</span><br><span class="hljs-number">2</span><br>~<span class="hljs-built_in">A</span>()<br></code></pre></td></tr></table></figure><h1 id="shared-from-this"><a href="#shared-from-this" class="headerlink" title="shared_from_this"></a>shared_from_this</h1><p>引用计数错误还可能有下面的情况：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>():<span class="hljs-built_in">mptr</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>) <br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;A()&quot;</span> &lt;&lt; endl;<br>&#125;<br>~<span class="hljs-built_in">A</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;~A()&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">delete</span> mptr; <br>mptr = <span class="hljs-literal">nullptr</span>;<br>&#125;<br> <br><span class="hljs-comment">// 返回指向自身对象的shared_ptr智能指针。</span><br><span class="hljs-function">shared_ptr&lt;A&gt; <span class="hljs-title">getSharedPtr</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123; <br><span class="hljs-keyword">return</span> <span class="hljs-built_in">shared_ptr</span>&lt;A&gt;(<span class="hljs-keyword">this</span>); <br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> *mptr;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">shared_ptr&lt;A&gt; <span class="hljs-title">ptr1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> A())</span></span>;<br>shared_ptr&lt;A&gt; ptr2 = ptr1-&gt;<span class="hljs-built_in">getSharedPtr</span>();<br><br>cout &lt;&lt; ptr1.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl; <br>cout &lt;&lt; ptr2.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">A</span><span class="hljs-params">()</span></span><br><span class="hljs-number">1</span><br><span class="hljs-number">1</span><br>~<span class="hljs-built_in">A</span>()<br>~<span class="hljs-built_in">A</span>()<br></code></pre></td></tr></table></figure><p>上面的代码智能指针的引用计数也有问题，虽然指向的是同一个A对象，但引用计数都为1，会造成重复释放。<br>当运行return shared_ptr&lt; A &gt;(this)时，会调用shared_ptr智能指针的构造函数，对this指针指向的对象，又建立了一份引用计数对象。<br>如果要给类提供一个接口返回指向当前对象的shared_ptr，可以继承enable_shared_from_this类，然后通过调用从基类继承来的shared_from_this()方法返回指向同一个资源对象的智能指针shared_ptr。<br><br/></p><p>enable_shared_from_this的成员变量有:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Ty</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">enable_shared_from_this</span><br>&#123;<span class="hljs-comment">// provide member functions that create shared_ptr to this</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">using</span> _Esft_type = enable_shared_from_this;<br><br><span class="hljs-function">_NODISCARD shared_ptr&lt;_Ty&gt; <span class="hljs-title">shared_from_this</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">// return shared_ptr</span><br>    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">shared_ptr</span>&lt;_Ty&gt;(_Wptr));<br>&#125;<br><span class="hljs-comment">// 成员变量是一个指向资源的弱智能指针</span><br><span class="hljs-keyword">mutable</span> weak_ptr&lt;_Ty&gt; _Wptr;<br>&#125;;<br></code></pre></td></tr></table></figure><p>如果一个类继承了enable_shared_from_this，那么它产生的对象就会从基类enable_shared_from_this继承一个成员变量_Wptr，当定义第一个智能指针对象的时候shared_ptr&lt; A &gt; ptr1(new A())，调用shared_ptr的普通构造函数，就会初始化A对象的成员变量_Wptr，作为观察A对象资源的一个弱智能指针观察者。<br>代码可以通过调用shared_from_this：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">shared_ptr&lt;_Ty&gt; <span class="hljs-title">shared_from_this</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">// return shared_ptr</span><br>    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">shared_ptr</span>&lt;_Ty&gt;(_Wptr));<br>&#125;<br></code></pre></td></tr></table></figure><p>shared_ptr&lt; _Ty &gt;(_Wptr)，说明通过当前A对象的成员变量_Wptr构造一个shared_ptr出来的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">shared_ptr</span>(<span class="hljs-type">const</span> weak_ptr&lt;_Ty2&gt;&amp; _Other)<br>&#123;<span class="hljs-comment">// construct shared_ptr object that owns resource *_Other</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>-&gt;_Construct_from_weak(_Other)) <span class="hljs-comment">// 从弱智能指针提升一个强智能指针</span><br>&#123;<br>    _THROW(bad_weak_ptr&#123;&#125;);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Ty2</span>&gt;<br><span class="hljs-type">bool</span> _Construct_from_weak(<span class="hljs-type">const</span> weak_ptr&lt;_Ty2&gt;&amp; _Other)<br>&#123;<span class="hljs-comment">// implement shared_ptr&#x27;s ctor from weak_ptr, and weak_ptr::lock()</span><br><span class="hljs-comment">// if通过判断资源的引用计数是否还在，判定对象的存活状态，对象存活，提升成功；</span><br><span class="hljs-comment">// 对象析构，提升失败！</span><br>    <span class="hljs-keyword">if</span> (_Other._Rep &amp;&amp; _Other._Rep-&gt;_Incref_nz())<br>    &#123;<br>        _Ptr = _Other._Ptr;<br>        _Rep = _Other._Rep;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-literal">true</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> (<span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="修改后的代码"><a href="#修改后的代码" class="headerlink" title="修改后的代码"></a>修改后的代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> : <span class="hljs-keyword">public</span> enable_shared_from_this&lt;A&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>() :<span class="hljs-built_in">mptr</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;A()&quot;</span> &lt;&lt; endl;<br>&#125;<br>~<span class="hljs-built_in">A</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;~A()&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">delete</span> mptr;<br>mptr = <span class="hljs-literal">nullptr</span>;<br>&#125;<br><br><span class="hljs-function">shared_ptr&lt;A&gt; <span class="hljs-title">getSharedPtr</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">shared_from_this</span>();<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> *mptr;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">shared_ptr&lt;A&gt; <span class="hljs-title">ptr1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> A())</span></span>;<br>shared_ptr&lt;A&gt; ptr2 = ptr1-&gt;<span class="hljs-built_in">getSharedPtr</span>();<br><br>cout &lt;&lt; ptr1.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>cout &lt;&lt; ptr2.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">A</span><span class="hljs-params">()</span></span><br><span class="hljs-number">2</span><br><span class="hljs-number">2</span><br>~<span class="hljs-built_in">A</span>()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>智能指针</title>
    <link href="/2022/09/04/2022-9-4-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    <url>/2022/09/04/2022-9-4-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>裸指针的坏处：<br>1、忘记释放资源，导致资源泄露（常发生内存泄漏问题）；<br>2、同一资源释放多次，导致释放野指针，程序崩溃；<br>3、明明代码的后面写了释放资源的代码，但是由于程序逻辑满足条件，从中间return掉了，导致释放资源的代码未被执行到；<br>4、代码运行过程中发生异常，随着异常栈展开，导致释放资源的代码未被执行到。<br><br/><br>使用智能指针后用户可以不关注资源的释放，因为智能指针会帮你完全管理资源的释放，它会保证无论程序逻辑怎么跑，正常执行或者产生异常，资源在到期的情况下，一定会进行释放。<br>C++11库里面，提供了带引用计数的智能指针和不带引用计数的智能指针，包括auto_ptr，scoped_ptr，unique_ptr，shared_ptr，weak_ptr。</p><h1 id="实现智能指针"><a href="#实现智能指针" class="headerlink" title="实现智能指针"></a>实现智能指针</h1><p>可以利用栈上的对象出作用域会自动析构的特点，自己实现一个简单的智能指针：<br>裸指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">如果这里忘记写delete，或者上面的代码段中程序return掉了，</span><br><span class="hljs-comment">没有执行到这里，都会导致这里没有释放内存，内存泄漏</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">delete</span> p;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>智能指针：提供*和-&gt;两种运算符的重载函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">mySmartPtr</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">mySmartPtr</span>(T *ptr = <span class="hljs-literal">nullptr</span>) :<span class="hljs-built_in">mptr</span>(ptr) &#123;&#125;<br>~<span class="hljs-built_in">mySmartPtr</span>() &#123; <span class="hljs-keyword">delete</span> mptr; &#125;<br><br>    T&amp; <span class="hljs-keyword">operator</span>*() &#123; <span class="hljs-keyword">return</span> *mptr; &#125;<br><span class="hljs-type">const</span> T&amp; <span class="hljs-keyword">operator</span>*()<span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> *mptr; &#125;<br><br>T* <span class="hljs-keyword">operator</span>-&gt;() &#123; <span class="hljs-keyword">return</span> mptr; &#125;<br><span class="hljs-type">const</span> T* <span class="hljs-keyword">operator</span>-&gt;()<span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> mptr; &#125;<br><br><span class="hljs-keyword">private</span>:<br>T *mptr;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">mySmartPtr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ptr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>)</span></span>;<br><br><span class="hljs-comment">/*由于ptr是栈上的智能指针对象，不管是函数正常执行完，还是运行过程中出现</span><br><span class="hljs-comment">异常，栈上的对象都会自动调用析构函数，在析构函数中进行了delete</span><br><span class="hljs-comment">操作，保证释放资源*/</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以智能指针一般是定义在栈上的，如果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">mySmartPtr *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">mySmartPtr</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>);<br></code></pre></td></tr></table></figure><p>上面定义的p虽然是智能指针类型，但它实质上还是一个裸指针，因此p还是需要进行手动delete</p><h1 id="不带引用计数的智能指针"><a href="#不带引用计数的智能指针" class="headerlink" title="不带引用计数的智能指针"></a>不带引用计数的智能指针</h1><p>auto_ptr，scoped_ptr，unique_ptr</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">mySmartPtr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ptr1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>)</span></span>;<br><span class="hljs-function">mySmartPtr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ptr2</span><span class="hljs-params">(ptr1)</span></span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个main函数运行时，代码直接会崩溃，问题出在默认的拷贝构造函数做的是浅拷贝，两个智能指针都持有一个new int资源，ptr2先析构释放了资源，到ptr1析构的时候，就成了delete野指针了，造成程序崩溃。所以智能指针还要解决浅拷贝和保证资源只能释放一次的问题。</p><h2 id="auto-ptr"><a href="#auto-ptr" class="headerlink" title="auto_ptr"></a>auto_ptr</h2><p>当发生上面的情况时，只有最后一个auto_ptr智能指针持有资源，原来的auto_ptr都被赋nullptr。auto_ptr智能指针不带引用计数，那么它处理浅拷贝的问题，是直接把前面的auto_ptr都置为nullptr，只让最后一个auto_ptr持有资源。<br>所以auto_ptr不能使用在容器当中，最好不要使用auto_ptr，除非应用场景非常简单。</p><h2 id="scoped-ptr"><a href="#scoped-ptr" class="headerlink" title="scoped_ptr"></a>scoped_ptr</h2><p>scoped_ptr私有化了拷贝构造函数和operator=赋值函数，从根本上杜绝了智能指针浅拷贝的发生</p><h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><p>unique_ptr去掉了拷贝构造函数和operator=赋值重载函数，禁止用户对unique_ptr进行显示的拷贝构造和赋值，防止智能指针浅拷贝问题的发生。但是unique_ptr提供了带右值引用参数的拷贝构造和赋值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ptr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>)</span></span>;<br>unique_ptr&lt;<span class="hljs-type">int</span>&gt; ptr2 = std::<span class="hljs-built_in">move</span>(ptr); <span class="hljs-comment">// 使用了右值引用的拷贝构造</span><br>ptr2 = std::<span class="hljs-built_in">move</span>(ptr);                 <span class="hljs-comment">// 使用了右值引用的operator=赋值重载函数</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">test_uniqueptr</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ptr1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>)</span></span>;<br><span class="hljs-keyword">return</span> ptr1;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>unique_ptr&lt;<span class="hljs-type">int</span>&gt; ptr = <span class="hljs-built_in">test_uniqueptr</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="带引用计数的智能指针"><a href="#带引用计数的智能指针" class="headerlink" title="带引用计数的智能指针"></a>带引用计数的智能指针</h1><p>shared_ptr、weak_ptr  </p><p>可以用p.use_count()来查看引用计数。对于整数的++或者- -操作，它并不是线程安全的操作，因此shared_ptr和weak_ptr底层的引用计数已经通过CAS操作，保证了引用计数加减的原子特性，因此shared_ptr和weak_ptr本身就是线程安全的带引用计数的智能指针。</p><h2 id="实现shared-ptr"><a href="#实现shared-ptr" class="headerlink" title="实现shared_ptr"></a>实现shared_ptr</h2><h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><p>实现shared_ptr 满足下面的功能：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;default constructor&quot;</span> &lt;&lt; endl; &#125;<br>    ~<span class="hljs-built_in">A</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;destructor&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">int</span> y;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    shared_ptr p = <span class="hljs-built_in">make_shared</span>();<br>    p-&gt;x = <span class="hljs-number">3</span>;<br>    p-&gt;y = <span class="hljs-number">4</span>;<br>    cout &lt;&lt; *p &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;p.use_count = &quot;</span> &lt;&lt; p.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br><br>    shared_ptr q = p;<br>    cout &lt;&lt; <span class="hljs-string">&quot;p.use_count = &quot;</span> &lt;&lt; p.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;q.use_count = &quot;</span> &lt;&lt; q.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl; <br><br>    p = <span class="hljs-literal">nullptr</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;q.use_count = &quot;</span> &lt;&lt; q.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>    q = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-comment">// 在此之前完成对象的析构</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;end main&quot;</span> &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ptr_data</span> &#123;                        <span class="hljs-comment">// 嵌套存储智能指针的数据</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ptr_data</span>(A *ptr, <span class="hljs-type">int</span> *cnt = <span class="hljs-literal">nullptr</span>)<br>    : <span class="hljs-built_in">ptr</span>(ptr), <span class="hljs-built_in">cnt</span>(cnt) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;cnt == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">this</span>-&gt;cnt = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">increase_one</span><span class="hljs-params">()</span> </span>&#123;<br>        *cnt += <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">decrease_one</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        *cnt -= <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (*cnt == <span class="hljs-number">0</span>) <span class="hljs-keyword">delete</span> ptr;<br>    &#125;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> ptr_data &amp;p) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> p.ptr == ptr &amp;&amp; p.cnt == cnt;<br>    &#125;<br>    ~<span class="hljs-built_in">ptr_data</span>() &#123;<br>        <span class="hljs-built_in">decrease_one</span>();<br>        <span class="hljs-keyword">if</span> (*cnt == <span class="hljs-number">0</span>) <span class="hljs-keyword">delete</span> cnt;<br>    &#125;<br>    A *ptr;<br>    <span class="hljs-type">int</span> *cnt;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">shared_ptr</span> &#123;                          <span class="hljs-comment">// 智能指针</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">shared_ptr</span>(A *ptr) : <span class="hljs-built_in">p</span>(ptr) &#123;&#125; <br>    <span class="hljs-built_in">shared_ptr</span>(<span class="hljs-type">const</span> shared_ptr &amp;p) : <span class="hljs-built_in">p</span>(p.p) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;p.<span class="hljs-built_in">increase_one</span>();<br>    &#125;<br><br>    shared_ptr &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> shared_ptr &amp;obj) &#123;<br>        <span class="hljs-keyword">if</span> (obj.p == p) <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;      <span class="hljs-comment">// 两个智能指针对象是否指向同一个对象</span><br>        p.<span class="hljs-built_in">decrease_one</span>();                  <span class="hljs-comment">// 把当前对象的引用计数减一</span><br>        p = obj.p;                         <span class="hljs-comment">// 赋值</span><br>        p.<span class="hljs-built_in">increase_one</span>();                  <span class="hljs-comment">// 新的对象的引用计数加一</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    A *<span class="hljs-keyword">operator</span>-&gt;() &#123; <span class="hljs-keyword">return</span> p.ptr; &#125;<br>    A &amp;<span class="hljs-keyword">operator</span>*() &#123; <span class="hljs-keyword">return</span> *p.ptr; &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">use_count</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> *p.cnt; &#125;<br>    ~<span class="hljs-built_in">shared_ptr</span>() &#123;<br>        p.<span class="hljs-built_in">decrease_one</span>();<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    ptr_data p;<br>&#125;;<br><br><span class="hljs-function">shared_ptr <span class="hljs-title">make_shared</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">shared_ptr</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">A</span>());<br>&#125;<br><br>ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="hljs-type">const</span> A &amp;a) &#123;<br>    out &lt;&lt; <span class="hljs-string">&quot;class A : &quot;</span> &lt;&lt; a.x &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; a.y;<br>    <span class="hljs-keyword">return</span> out;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="环形引用"><a href="#环形引用" class="headerlink" title="环形引用"></a>环形引用</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>; <span class="hljs-comment">// 前置声明类B</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;A()&quot;</span> &lt;&lt; endl; &#125;<br>~<span class="hljs-built_in">A</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;~A()&quot;</span> &lt;&lt; endl; &#125;<br>shared_ptr&lt;B&gt; _ptrb;               <span class="hljs-comment">// 指向B对象的智能指针</span><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">B</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;B()&quot;</span> &lt;&lt; endl; &#125;<br>~<span class="hljs-built_in">B</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;~B()&quot;</span> &lt;&lt; endl; &#125;<br>shared_ptr&lt;A&gt; _ptra;               <span class="hljs-comment">// 指向A对象的智能指针</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">shared_ptr&lt;A&gt; <span class="hljs-title">ptra</span><span class="hljs-params">(<span class="hljs-keyword">new</span> A())</span></span>;       <span class="hljs-comment">// ptra指向A对象，A的引用计数为1</span><br><span class="hljs-function">shared_ptr&lt;B&gt; <span class="hljs-title">ptrb</span><span class="hljs-params">(<span class="hljs-keyword">new</span> B())</span></span>;       <span class="hljs-comment">// ptrb指向B对象，B的引用计数为1</span><br>ptra-&gt;_ptrb = ptrb;                <span class="hljs-comment">// A对象的成员变量_ptrb也指向B对象，B的引用计数为2</span><br>ptrb-&gt;_ptra = ptra;                <span class="hljs-comment">// B对象的成员变量_ptra也指向A对象，A的引用计数为2</span><br><br>cout &lt;&lt; ptra.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;  <span class="hljs-comment">// 打印A的引用计数结果:2</span><br>cout &lt;&lt; ptrb.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;  <span class="hljs-comment">// 打印B的引用计数结果:2</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">出main函数作用域，ptra和ptrb两个局部对象析构，分别给A对象和</span><br><span class="hljs-comment">B对象的引用计数从2减到1，达不到释放A和B的条件（释放的条件是</span><br><span class="hljs-comment">A和B的引用计数为0），因此造成两个new出来的A和B对象无法释放，</span><br><span class="hljs-comment">导致内存泄露</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">A</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">B</span><span class="hljs-params">()</span></span><br><span class="hljs-number">2</span><br><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h2 id="避免环形引用"><a href="#避免环形引用" class="headerlink" title="避免环形引用"></a>避免环形引用</h2><p>定义对象时，用强智能指针shared_ptr，在其它地方引用对象时，使用弱智能指针weak_ptr。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>; <span class="hljs-comment">// 前置声明类B</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;A()&quot;</span> &lt;&lt; endl; &#125;<br>~<span class="hljs-built_in">A</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;~A()&quot;</span> &lt;&lt; endl; &#125;<br>weak_ptr&lt;B&gt; _ptrb;                  <span class="hljs-comment">// 指向B对象的弱智能指针。引用对象时，用弱智能指针</span><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">B</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;B()&quot;</span> &lt;&lt; endl; &#125;<br>~<span class="hljs-built_in">B</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;~B()&quot;</span> &lt;&lt; endl; &#125;<br>weak_ptr&lt;A&gt; _ptra;                  <span class="hljs-comment">// 指向A对象的弱智能指针。引用对象时，用弱智能指针</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 定义对象时，用强智能指针</span><br><span class="hljs-function">shared_ptr&lt;A&gt; <span class="hljs-title">ptra</span><span class="hljs-params">(<span class="hljs-keyword">new</span> A())</span></span>;        <span class="hljs-comment">// ptra指向A对象，A的引用计数为1</span><br><span class="hljs-function">shared_ptr&lt;B&gt; <span class="hljs-title">ptrb</span><span class="hljs-params">(<span class="hljs-keyword">new</span> B())</span></span>;        <span class="hljs-comment">// ptrb指向B对象，B的引用计数为1</span><br><span class="hljs-comment">// A对象的成员变量_ptrb也指向B对象，B的引用计数为1，因为是弱智能指针，引用计数没有改变</span><br>ptra-&gt;_ptrb = ptrb;<br><span class="hljs-comment">// B对象的成员变量_ptra也指向A对象，A的引用计数为1，因为是弱智能指针，引用计数没有改变</span><br>ptrb-&gt;_ptra = ptra;<br><br>cout &lt;&lt; ptra.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;   <span class="hljs-comment">// 打印结果:1</span><br>cout &lt;&lt; ptrb.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;   <span class="hljs-comment">// 打印结果:1</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">出main函数作用域，ptra和ptrb两个局部对象析构，分别给A对象和</span><br><span class="hljs-comment">B对象的引用计数从1减到0，达到释放A和B的条件，因此new出来的A和B对象</span><br><span class="hljs-comment">被析构掉，解决了“强智能指针的交叉引用(循环引用)问题”</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">A</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">B</span><span class="hljs-params">()</span></span><br><span class="hljs-number">1</span><br><span class="hljs-number">1</span><br>~<span class="hljs-built_in">B</span>()<br>~<span class="hljs-built_in">A</span>()<br></code></pre></td></tr></table></figure><h1 id="多线程情况下"><a href="#多线程情况下" class="headerlink" title="多线程情况下"></a>多线程情况下</h1><p>多线程访问共享对象的线程安全问题：线程A和线程B访问一个共享的对象，如果线程A正在析构这个对象的时候，线程B又要调用该共享对象的成员方法，此时可能线程A已经把对象析构完了，线程B再去访问该对象，就会发生不可预期的错误。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Test</span>() :_ptr(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">20</span>)) <br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Test()&quot;</span> &lt;&lt; endl;<br>&#125;<br><br>~<span class="hljs-built_in">Test</span>()<br>&#123;<br><span class="hljs-keyword">delete</span> _ptr;<br>_ptr = <span class="hljs-literal">nullptr</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;~Test()&quot;</span> &lt;&lt; endl;<br>&#125;<br>                            <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span>                     <span class="hljs-comment">// 该方法会在另外一个线程中被执行</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; *_ptr &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> *<span class="hljs-keyword">volatile</span> _ptr;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">threadProc</span><span class="hljs-params">(Test *p)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 睡眠两秒，此时main主线程已经把Test对象给delete掉了</span><br>std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">2</span>));<br><br>p-&gt;<span class="hljs-built_in">func</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>Test *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Test</span>();<br><br><span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(threadProc, p)</span></span>;<br><br><span class="hljs-keyword">delete</span> p;<br><br>t1.<span class="hljs-built_in">join</span>();                      <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以使用智能指针来解决上面的线程安全问题：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">threadProc</span><span class="hljs-params">(weak_ptr&lt;Test&gt; pw)</span> <span class="hljs-comment">// 通过弱智能指针观察强智能指针</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 睡眠两秒</span><br>std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">2</span>));<br><span class="hljs-comment">/* </span><br><span class="hljs-comment">如果想访问对象的方法，先通过pw的lock方法进行提升操作，把weak_ptr提升</span><br><span class="hljs-comment">为shared_ptr强智能指针，提升过程中，是通过检测它所观察的强智能指针保存</span><br><span class="hljs-comment">的Test对象的引用计数，来判定Test对象是否存活，ps如果为nullptr，说明Test对象</span><br><span class="hljs-comment">已经析构，不能再访问；如果ps!=nullptr，则可以正常访问Test对象的方法。</span><br><span class="hljs-comment">*/</span><br>shared_ptr&lt;Test&gt; ps = pw.<span class="hljs-built_in">lock</span>();<br><span class="hljs-keyword">if</span> (ps != <span class="hljs-literal">nullptr</span>)<br>&#123;<br>ps-&gt;<span class="hljs-built_in">func</span>();<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">shared_ptr&lt;Test&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Test)</span></span>;<br><br><span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(threadProc, weak_ptr&lt;Test&gt;(p))</span></span>;  <span class="hljs-comment">// 并传入共享对象的弱智能指针</span><br><br>t1.<span class="hljs-built_in">join</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="自定义智能指针的析构"><a href="#自定义智能指针的析构" class="headerlink" title="自定义智能指针的析构"></a>自定义智能指针的析构</h1><p>我们经常用智能指针管理的资源是堆内存，当智能指针出作用域的时候，在其析构函数中会delete释放堆内存资源，但是除了堆内存资源，智能指针还可以管理其它资源，比如打开的文件，此时对于文件指针的关闭，就不能用delete了，这时我们需要自定义智能指针释放资源的方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 自定义智能指针删除器，关闭文件资源</span><br>unique_ptr&lt;FILE, function&lt;<span class="hljs-type">void</span>(FILE*)&gt;&gt; <br><span class="hljs-built_in">filePtr</span>(<span class="hljs-built_in">fopen</span>(<span class="hljs-string">&quot;data.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>), [](FILE *pf)-&gt;<span class="hljs-type">void</span>&#123;<span class="hljs-built_in">fclose</span>(pf);&#125;);<br><br><span class="hljs-comment">// 自定义智能指针删除器，释放数组资源</span><br>unique_ptr&lt;<span class="hljs-type">int</span>, function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>*)&gt;&gt;<br><span class="hljs-built_in">arrayPtr</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">100</span>], [](<span class="hljs-type">int</span> *ptr)-&gt;<span class="hljs-type">void</span> &#123;<span class="hljs-keyword">delete</span>[]ptr; &#125;);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图像质量诊断：模糊度评估</title>
    <link href="/2022/09/01/2022-9-01-%E5%9B%BE%E5%83%8F%E8%B4%A8%E9%87%8F%E6%A3%80%E6%B5%8B-%E6%A8%A1%E7%B3%8A%E5%BA%A6%E8%AF%84%E4%BC%B0/"/>
    <url>/2022/09/01/2022-9-01-%E5%9B%BE%E5%83%8F%E8%B4%A8%E9%87%8F%E6%A3%80%E6%B5%8B-%E6%A8%A1%E7%B3%8A%E5%BA%A6%E8%AF%84%E4%BC%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="图像模糊度检测"><a href="#图像模糊度检测" class="headerlink" title="图像模糊度检测"></a>图像模糊度检测</h1><p>无参考图像的图像模糊度评估</p><h2 id="拉普拉斯"><a href="#拉普拉斯" class="headerlink" title="拉普拉斯"></a>拉普拉斯</h2><h3 id="拉普拉斯算子"><a href="#拉普拉斯算子" class="headerlink" title="拉普拉斯算子"></a>拉普拉斯算子</h3><p>拉普拉斯算子是图像邻域内像素灰度差分计算的基础，通过二阶微分推导出的一种图像邻域增强算法。它的基本思想是当邻域的中心像素灰度低于它所在邻域内的其他像素的平均灰度时，此中心像素的灰度应该进一步降低；当高于时进一步提高中心像素的灰度，从而实现图像锐化处理。  </p><p>Laplacian 方法能够进行模糊检测工作的原因是 Laplacian 算子是用来衡量图片的二阶导，能够强调图片中密度快速变化的区域，也就是边界，故常用于边界检测。在正常图片中边界比较清晰因此方差会比较大；而在模糊图片中包含的边界信息很少，所以方差会较小。  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Laplacian</span><span class="hljs-params">(InputArray src, </span></span><br><span class="hljs-params"><span class="hljs-function">                outputArray dst, </span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-type">int</span> ddepth,                     <span class="hljs-comment">// 目标图像的深度</span></span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-type">int</span> ksize=<span class="hljs-number">1</span>,                    <span class="hljs-comment">// 计算二阶导数的滤波器的核的大小</span></span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-type">double</span> scale=<span class="hljs-number">1</span>,                 <span class="hljs-comment">// 比例因子</span></span></span><br><span class="hljs-params"><span class="hljs-function">                doubel delta=<span class="hljs-number">0</span>, </span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-type">int</span> borderType=BORDER_DEFAULT)</span></span><br></code></pre></td></tr></table></figure><br/><p>例子：<br>laplacion对噪声的敏感度较大，一般会加上GaussianBulr先处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">cv::Mat lena = cv::<span class="hljs-built_in">imread</span>(<span class="hljs-string">&quot;xxx.jpg&quot;</span>, <span class="hljs-number">1</span>);<br><br>cv::Mat result_1;<br>cv::Mat result_2；<br><br>cv::<span class="hljs-built_in">GaussianBlur</span>(lena, blured, cv::<span class="hljs-built_in">Size</span>(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>cv::<span class="hljs-built_in">Laplacian</span>(lena, result_1, CV_32F);<br>cv::<span class="hljs-built_in">Laplacian</span>(blured, result_2, CV_32F);<br><br>cv::<span class="hljs-built_in">imshow</span>(<span class="hljs-string">&quot;lena&quot;</span>, lena);<br>cv::<span class="hljs-built_in">imshow</span>(<span class="hljs-string">&quot;result_1 CV_32F&quot;</span>, result_1);<br>cv::<span class="hljs-built_in">imshow</span>(<span class="hljs-string">&quot;result_2 CV_32F + Gaussian&quot;</span>, result_2);<br></code></pre></td></tr></table></figure><p><img src="/img/2022-8-27%E8%A7%86%E9%A2%91%E8%AF%8A%E6%96%AD/cat05.jpg" alt="拉普拉斯"></p><h3 id="meanStdDev"><a href="#meanStdDev" class="headerlink" title="meanStdDev()"></a>meanStdDev()</h3><p>该函数可以表示一个图像的明暗变化程度，标准差越大，明暗变化越明显。<br>均值反映了图像的亮度，均值越大说明图像亮度越大，反之越小；<br>标准差反映了图像像素值与均值的离散程度，标准差越大说明图像的质量越好；<br>平均梯度反映了图像的清晰度和纹理变化，平均梯度越大说明图像越清晰；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">meanStdDev</span><span class="hljs-params">(InputArray src, </span></span><br><span class="hljs-params"><span class="hljs-function">                OutputArray mean,               <span class="hljs-comment">// 输出参数，计算出的平均值</span></span></span><br><span class="hljs-params"><span class="hljs-function">                OutputArray stddev,             <span class="hljs-comment">// 输出参数，计算出的标准差</span></span></span><br><span class="hljs-params"><span class="hljs-function">                InputArray mask=noArray())</span></span>;<br></code></pre></td></tr></table></figure><h2 id="评估方法"><a href="#评估方法" class="headerlink" title="评估方法"></a>评估方法</h2><p>拉普拉斯算子做卷积运算，再根据方差来评估，输出即为模糊度；normal_std和normal_mean为事先设定的阈值，分别是标准差系数和模糊度均值。</p><h2 id="部分代码"><a href="#部分代码" class="headerlink" title="部分代码"></a>部分代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">float</span> normal_std = <span class="hljs-number">0.5f</span>;<br><span class="hljs-type">float</span> normal_mean = <span class="hljs-number">10.0f</span>;<br><br>cv::Mat gray, lap;<br>cv::<span class="hljs-built_in">cvtColor</span>(image, gray, cv::COLOR_BGR2GRAY);<br><br>cv::<span class="hljs-built_in">Laplacian</span>(gray, lap, CV_8UC1);<br><br>cv::Scalar mean, std;      <span class="hljs-comment">// 颜色</span><br><br>cv::<span class="hljs-built_in">meanStdDev</span>(lap, mean, std); <span class="hljs-comment">// mean：平均值, std:标准差</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">float</span>(<span class="hljs-number">1.0</span> / (<span class="hljs-number">1.0</span> + cv::<span class="hljs-built_in">exp</span>((std[<span class="hljs-number">0</span>] - normal_mean) * normal_std)));<br></code></pre></td></tr></table></figure><p><img src="/img/2022-8-27%E8%A7%86%E9%A2%91%E8%AF%8A%E6%96%AD/blur_flower02.jpg" alt="模糊度:0.003713"><br><img src="/img/2022-8-27%E8%A7%86%E9%A2%91%E8%AF%8A%E6%96%AD/blur_flower01.jpg" alt="模糊度:0.649901"></p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>视频质量诊断</tag>
      
      <tag>opencv</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nginx映射本地路径到url请求</title>
    <link href="/2022/08/30/2022-8-30-nginx%E6%98%A0%E5%B0%84%E6%9C%AC%E5%9C%B0%E8%B7%AF%E5%BE%84%E5%88%B0url%E8%AF%B7%E6%B1%82/"/>
    <url>/2022/08/30/2022-8-30-nginx%E6%98%A0%E5%B0%84%E6%9C%AC%E5%9C%B0%E8%B7%AF%E5%BE%84%E5%88%B0url%E8%AF%B7%E6%B1%82/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>将本地程序生成的图片通过nginx代理，使外部可以通过url访问指定ip:端口/路径进行下载。</p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><h2 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h2><p>为了不影响外部其他程序，将nginx放在容器中运行，首先获取nginx的镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pull nginx<br></code></pre></td></tr></table></figure><p>启动容器，并将本地存放图片的路径映射到docker里（将项目根目录下的images文件映射到docker里的/home/www）, 同时进行端口的映射（docker内的80端口映射到外部的8080端口）： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -itd --name nginx-pic -v $PWD/images:/home/www -p 8080:80/tcp nginx <br></code></pre></td></tr></table></figure><p>此时进入容器可以看到/home/www/下存放着需要处理的图片。</p><h2 id="nginx配置"><a href="#nginx配置" class="headerlink" title="nginx配置"></a>nginx配置</h2><p>修改/etc/nginx/conf.d/default.conf:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;<br>    <span class="hljs-section">location</span><span class="hljs-regexp"> ^~/images/</span> &#123;<br>    <span class="hljs-attribute">alias</span> /home/www/;<br>        <span class="hljs-attribute">autoindex</span> <span class="hljs-literal">on</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>alias指定的是绝对路径，此时保存退出，执行命令重载配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nginx -s reload<br></code></pre></td></tr></table></figure><p>完成后即可通过 ：ip:8080/images下载到本地项目路径下images的图片。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nginx</tag>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cout和printf的笔记</title>
    <link href="/2022/08/28/2022-8-28-cout%E5%92%8Cprintf%E7%9A%84%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/08/28/2022-8-28-cout%E5%92%8Cprintf%E7%9A%84%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>在打印cv::Mat.data时出现了下面的现象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> cv;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cv::Mat A = cv::<span class="hljs-built_in">imread</span>(<span class="hljs-string">&quot;../opencv_test.jpg&quot;</span>);<br><span class="hljs-function">cv::Mat <span class="hljs-title">B</span><span class="hljs-params">(A)</span></span>;<br>cv::Mat C = A;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;A.data = %p\nB.data = %p\nC.data = %p\n&quot;</span>, A.data, B.data, C.data);<br>    <br>    <span class="hljs-comment">// cout &lt;&lt; A.data &lt;&lt; endl;</span><br>    <br>    cout &lt;&lt; <span class="hljs-string">&quot;(void*)A.data:  &quot;</span> &lt;&lt; (<span class="hljs-type">void</span>*)A.data &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;(void*)B.data:  &quot;</span> &lt;&lt; (<span class="hljs-type">void</span>*)B.data &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;(void*)C.data:  &quot;</span> &lt;&lt; (<span class="hljs-type">void</span>*)C.data &lt;&lt; endl;<br>    <br>    cout &lt;&lt; <span class="hljs-string">&quot;&amp;A.data:  &quot;</span> &lt;&lt; &amp;A.data &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;&amp;B.data:  &quot;</span> &lt;&lt; &amp;B.data &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;&amp;C.data:  &quot;</span> &lt;&lt; &amp;C.data &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-type">A</span>.<span class="hljs-class"><span class="hljs-keyword">data</span> = 0x7f3ac2275040</span><br><span class="hljs-type">B</span>.<span class="hljs-class"><span class="hljs-keyword">data</span> = 0x7f3ac2275040</span><br><span class="hljs-type">C</span>.<span class="hljs-class"><span class="hljs-keyword">data</span> = 0x7f3ac2275040</span><br>(void*)<span class="hljs-type">A</span>.<span class="hljs-class"><span class="hljs-keyword">data</span>:  0x7f3ac2275040</span><br>(void*)<span class="hljs-type">B</span>.<span class="hljs-class"><span class="hljs-keyword">data</span>:  0x7f3ac2275040</span><br>(void*)<span class="hljs-type">C</span>.<span class="hljs-class"><span class="hljs-keyword">data</span>:  0x7f3ac2275040</span><br>&amp;<span class="hljs-type">A</span>.<span class="hljs-class"><span class="hljs-keyword">data</span>:  0x7ffee9658480</span><br>&amp;<span class="hljs-type">B</span>.<span class="hljs-class"><span class="hljs-keyword">data</span>:  0x7ffee9658420</span><br>&amp;<span class="hljs-type">C</span>.<span class="hljs-class"><span class="hljs-keyword">data</span>:  0x7ffee96583c0</span><br></code></pre></td></tr></table></figure><br/><p>如果这样写，会输出一大段乱码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">cout &lt;&lt; A.data &lt;&lt; endl;<br></code></pre></td></tr></table></figure><h1 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h1><p>Mat::data是数据段的首地址，在C语言中，是靠%s,%x,%p来区分指针表达式的，所以就会直接打印出正确的data首地址出来；C++标准库中I/O类对输出操作符&lt;&lt;重载，在遇到指针，例如字符型指针时会将其当做字符串名来处理，输出指针所指的字符串。例如：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span> ss[<span class="hljs-number">20</span>]=<span class="hljs-string">&quot;hello&quot;</span>;<br>cout&lt;&lt;ss&lt;&lt;endl;<br>cout&lt;&lt;&amp;ss[<span class="hljs-number">0</span>]&lt;&lt;endl;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hello</span><br><span class="hljs-attribute">hello</span><br></code></pre></td></tr></table></figure><p>这也说明用 “cout &lt;&lt; A.data &lt;&lt; endl;” 会输出一大串乱码； 我们只需要将char*类型的指针强制转换为其他类型的指针，cout就会输出指针存储的位置。上面的Mat.data也同理。Mat::data的默认类型为uchar *。<br>至于 “cout &lt;&lt; “&amp;A.data:  “ &lt;&lt; &amp;A.data &lt;&lt; endl;” 输出的地址有所不同，是因为取了指针的地址，三个对象的指针的地址是不同的。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
      <tag>opencv</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图像质量诊断：雪花噪声</title>
    <link href="/2022/08/28/2022-8-27-%E5%9B%BE%E5%83%8F%E8%B4%A8%E9%87%8F%E8%AF%8A%E6%96%AD-%E9%9B%AA%E8%8A%B1-%E6%A8%A1%E7%B3%8A%E5%BA%A6%E8%AF%84%E4%BC%B0/"/>
    <url>/2022/08/28/2022-8-27-%E5%9B%BE%E5%83%8F%E8%B4%A8%E9%87%8F%E8%AF%8A%E6%96%AD-%E9%9B%AA%E8%8A%B1-%E6%A8%A1%E7%B3%8A%E5%BA%A6%E8%AF%84%E4%BC%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="opencv"><a href="#opencv" class="headerlink" title="opencv"></a>opencv</h1><h2 id="cv-Mat"><a href="#cv-Mat" class="headerlink" title="cv::Mat"></a>cv::Mat</h2><p>opencv的Mat类，使得opencv的编程更加的简单,我们能得到如下好处:<br>1、不需要手动申请一块内存；<br>2、不需要手动释放内存；<br>3、通过类的封装能方便获取类的数据；  <br/><br>显然的，它利用了类的特性，将内存管理和数据信息封装在类的内部，用户只需要对Mat类对象进行数据或面向对象操作即可。<br>Mat类分为两个部分：矩阵头和矩阵数据。如果我们在操作一副图像的数据量时，矩阵数据的大小很大（一般约有1M的数据量），那么拷贝和赋值函数所作的操作如果的深拷贝的话，效率会大大的降低。所以，Opencv的做法是只复制其矩阵头信息，而矩阵数据采用引用的方式，即多个Mat对象共享同一个矩阵数据，这里使用的原理类似c++11中的共享指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">cv::Mat A = cv::<span class="hljs-built_in">imread</span>(<span class="hljs-string">&quot;../opencv_test.jpg&quot;</span>);<br><span class="hljs-function">cv::Mat <span class="hljs-title">B</span><span class="hljs-params">(A)</span></span>;<br>cv::Mat C = A;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;A.data = %p\nB.data = %p\nC.data = %p\n&quot;</span>, A.data, B.data, C.data);<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-type">A</span>.<span class="hljs-class"><span class="hljs-keyword">data</span> = 0x7f2c1fac5040</span><br><span class="hljs-type">B</span>.<span class="hljs-class"><span class="hljs-keyword">data</span> = 0x7f2c1fac5040</span><br><span class="hljs-type">C</span>.<span class="hljs-class"><span class="hljs-keyword">data</span> = 0x7f2c1fac5040</span><br></code></pre></td></tr></table></figure><p>三个Mat类对象的矩阵数据的地址是一样的。</p><h2 id="cv-cvtColor"><a href="#cv-cvtColor" class="headerlink" title="cv::cvtColor()"></a>cv::cvtColor()</h2><p>用于将图像从一个颜色空间转换到另一个颜色空间的转换。</p><h2 id="cv-blur"><a href="#cv-blur" class="headerlink" title="cv::blur()"></a>cv::blur()</h2><p>对输入的图像src进行均值滤波后用dst输出。</p><h3 id="均值滤波"><a href="#均值滤波" class="headerlink" title="均值滤波"></a>均值滤波</h3><p>对目标像素及周边像素取平均值后再填回目标像素来实现滤波目的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Mat imgOri = <span class="hljs-built_in">imread</span>(<span class="hljs-string">&quot;D:\\xxx.jpg&quot;</span>);<br><span class="hljs-built_in">namedWindow</span>(<span class="hljs-string">&quot;imgOri&quot;</span>);<br><span class="hljs-built_in">imshow</span>(<span class="hljs-string">&quot;imgOri&quot;</span>, imgOri);<br><br>Mat imgOut, gray;<br><span class="hljs-built_in">cvtColor</span>(imgOri, gray, COLOR_BGR2GRAY);<br><span class="hljs-built_in">blur</span>(gray, imgOut, &#123; <span class="hljs-number">3</span>, <span class="hljs-number">3</span> &#125;);<br><span class="hljs-built_in">namedWindow</span>(<span class="hljs-string">&quot;imgOut&quot;</span>);<br><span class="hljs-built_in">imshow</span>(<span class="hljs-string">&quot;imgOut&quot;</span>, imgOut);<br><br><span class="hljs-built_in">waitKey</span>(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/2022-8-27%E8%A7%86%E9%A2%91%E8%AF%8A%E6%96%AD/cat01.jpg" alt="图1"><br><img src="/img/2022-8-27%E8%A7%86%E9%A2%91%E8%AF%8A%E6%96%AD/cat02.jpg" alt="图2"></p><h2 id="cv-filter2D"><a href="#cv-filter2D" class="headerlink" title="cv::filter2D()"></a>cv::filter2D()</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cv::filter2D</span><span class="hljs-params">(InputArray   src,</span></span><br><span class="hljs-params"><span class="hljs-function">                  OutputArray  dst,</span></span><br><span class="hljs-params"><span class="hljs-function">                  <span class="hljs-type">int</span>          ddepth,</span></span><br><span class="hljs-params"><span class="hljs-function">                  InputArray   kernel,</span></span><br><span class="hljs-params"><span class="hljs-function">                  Point        anchor=Point(<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>),</span></span><br><span class="hljs-params"><span class="hljs-function">                  <span class="hljs-type">double</span>       delta=<span class="hljs-number">0</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                  <span class="hljs-type">int</span>          borderType=BORDER_DEFAULT</span></span><br><span class="hljs-params"><span class="hljs-function">                  )</span></span><br></code></pre></td></tr></table></figure><p>利用内核实现对图像的卷积运算，可用于自定义去噪。</p><h2 id="cv-min"><a href="#cv-min" class="headerlink" title="cv::min()"></a>cv::min()</h2><p>获取两个矩阵对应元素的最小值。</p><h2 id="Mat-forEach"><a href="#Mat-forEach" class="headerlink" title="Mat::forEach()"></a>Mat::forEach()</h2><p>遍历图像所有像素（并行处理）。</p><h1 id="雪花噪声评估"><a href="#雪花噪声评估" class="headerlink" title="雪花噪声评估"></a>雪花噪声评估</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>雪花噪声又叫椒盐噪声也称为脉冲噪声，是图像中经常见到的一种噪声，它是一种随机出现的白点或者黑点，可能是亮的区域有黑色像素或是在暗的区域有白色像素（或是两者皆有）。椒盐噪声的成因可能是影像讯号受到突如其来的强烈干扰而产生、模数转换器或位元传输错误等。<br>图像随机添加雪花噪声：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//椒盐噪声函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">saltAndPepper</span><span class="hljs-params">(Mat image, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; n; ++k) &#123;<br>        <span class="hljs-comment">//随机确定图像中位置</span><br>        <span class="hljs-type">int</span> i, j;<br>        i = <span class="hljs-built_in">rand</span>() % image.cols;                    <span class="hljs-comment">//取余数运算，保证在图像的列数内</span><br>        j = <span class="hljs-built_in">rand</span>() % image.rows;                    <span class="hljs-comment">//取余数运算，保证在图像的行数内</span><br>        <span class="hljs-type">int</span> write_black = <span class="hljs-built_in">rand</span>() % <span class="hljs-number">2</span>;               <span class="hljs-comment">//判定为白色噪声还是黑色噪声的变量</span><br>        <span class="hljs-keyword">if</span> (write_black == <span class="hljs-number">0</span>) &#123;                     <span class="hljs-comment">//添加白色噪声</span><br>            <span class="hljs-keyword">if</span> (image.<span class="hljs-built_in">type</span>() == CV_8UC1) &#123;          <span class="hljs-comment">//处理灰度图像</span><br>                image.<span class="hljs-built_in">at</span>&lt;uchar&gt;(j, i) = <span class="hljs-number">255</span>;        <span class="hljs-comment">//白色噪声</span><br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (image.<span class="hljs-built_in">type</span>() == CV_8UC3) &#123;     <span class="hljs-comment">//处理彩色图像</span><br>                image.<span class="hljs-built_in">at</span>&lt;Vec3b&gt;(j, i)[<span class="hljs-number">0</span>] = <span class="hljs-number">255</span>;     <span class="hljs-comment">//Vec3b为opencv定义的3个值的向量类型</span><br>                image.<span class="hljs-built_in">at</span>&lt;Vec3b&gt;(j, i)[<span class="hljs-number">1</span>] = <span class="hljs-number">255</span>;     <span class="hljs-comment">//[]制定通道，B:0,G:1,R:2</span><br>                image.<span class="hljs-built_in">at</span>&lt;Vec3b&gt;(j, i)[<span class="hljs-number">2</span>] = <span class="hljs-number">255</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;                                      <span class="hljs-comment">//添加黑噪声</span><br>            <span class="hljs-keyword">if</span> (image.<span class="hljs-built_in">type</span>() == CV_8UC1) &#123;<br>                image.<span class="hljs-built_in">at</span>&lt;uchar&gt;(j, i) = <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (image.<span class="hljs-built_in">type</span>() == CV_8UC3) &#123;<br>                image.<span class="hljs-built_in">at</span>&lt;Vec3b&gt;(j, i)[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;       <span class="hljs-comment">//Vec3b为opencv定义的3个值的向量类型</span><br>                image.<span class="hljs-built_in">at</span>&lt;Vec3b&gt;(j, i)[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;       <span class="hljs-comment">//[]制定通道，B:0,G:1,R:2</span><br>                image.<span class="hljs-built_in">at</span>&lt;Vec3b&gt;(j, i)[<span class="hljs-number">2</span>] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Mat img_ = <span class="hljs-built_in">imread</span>(<span class="hljs-string">&quot;D:\\0001\\cat01.jpg&quot;</span>);<br>    Mat img;<br>    <span class="hljs-built_in">resize</span>(img_, img, <span class="hljs-built_in">Size</span>(img_.cols, img_.rows));<br>    Mat gray;<br>    <span class="hljs-built_in">cvtColor</span>(img, gray, COLOR_BGR2GRAY);<br>    <span class="hljs-keyword">if</span> (img.<span class="hljs-built_in">empty</span>() || gray.<span class="hljs-built_in">empty</span>()) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;请确认输入的路径是否正确&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">imshow</span>(<span class="hljs-string">&quot;cat原图&quot;</span>, img);<br>    <span class="hljs-built_in">imshow</span>(<span class="hljs-string">&quot;cat_gray原图&quot;</span>, gray);<br>    <span class="hljs-built_in">saltAndPepper</span>(img, <span class="hljs-number">10000</span>);                      <span class="hljs-comment">//彩色图像添加椒盐噪声</span><br>    <span class="hljs-built_in">saltAndPepper</span>(gray, <span class="hljs-number">10000</span>);                     <span class="hljs-comment">//灰度图像添加椒盐噪声</span><br>    <span class="hljs-built_in">imshow</span>(<span class="hljs-string">&quot;cat添加噪声&quot;</span>, img);<br>    <span class="hljs-built_in">imshow</span>(<span class="hljs-string">&quot;cat_gray添加噪声&quot;</span>, gray);<br>    <span class="hljs-built_in">waitKey</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/2022-8-27%E8%A7%86%E9%A2%91%E8%AF%8A%E6%96%AD/cat03.jpg" alt="图3"><br><img src="/img/2022-8-27%E8%A7%86%E9%A2%91%E8%AF%8A%E6%96%AD/cat04.jpg" alt="图4"></p><p>当图片中的像素同时满足以下两个条件可以判定为噪点：<br>1、进行中值滤波，然后与原图进行比较，差距较大；<br>2、像素与周围像素的差距是否都很大：通过四个方向的卷积取最小值来比较。  </p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>定义卷积运算的卷积核</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::vector&lt;cv::Mat&gt; kernels = &#123;<br>            cv::<span class="hljs-built_in">Mat</span>(&#123;<span class="hljs-number">3</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">-2.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>&#125;),<br>            cv::<span class="hljs-built_in">Mat</span>(&#123;<span class="hljs-number">3</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">-2.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>&#125;),<br>            cv::<span class="hljs-built_in">Mat</span>(&#123;<span class="hljs-number">3</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">-2.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>&#125;),<br>            cv::<span class="hljs-built_in">Mat</span>(&#123;<span class="hljs-number">3</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">-2.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>&#125;),<br>    &#125;;<br></code></pre></td></tr></table></figure><p>将图片灰度化后进行均值滤波，取与原图像差的绝对值；再对灰度化的图片进行卷积运算，取四个方向与原图片差值的绝对值的最小值。将获得的这两个数与自己的设定的阈值作比较就是雪花噪声的像素点，最后所有的像素点占整幅图像的比例就是雪花噪声率。</p><h2 id="部分代码"><a href="#部分代码" class="headerlink" title="部分代码"></a>部分代码</h2><p>conv_thr和filter_thr为卷积差异阈值和中值滤波差异阈值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++">cv::Mat gray;<br>cv::<span class="hljs-built_in">cvtColor</span>(image, gray, cv::COLOR_BGR2GRAY);<br><br>std::vector&lt;cv::Mat&gt; kernels = &#123;<br>        cv::<span class="hljs-built_in">Mat</span>(&#123;<span class="hljs-number">3</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">-2.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>&#125;),<br>        cv::<span class="hljs-built_in">Mat</span>(&#123;<span class="hljs-number">3</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">-2.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>&#125;),<br>        cv::<span class="hljs-built_in">Mat</span>(&#123;<span class="hljs-number">3</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">-2.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>&#125;),<br>        cv::<span class="hljs-built_in">Mat</span>(&#123;<span class="hljs-number">3</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">-2.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>&#125;),<br>&#125;;<br><br><span class="hljs-comment">/* 中值滤波 */</span><br>cv::Mat median;<br>cv::<span class="hljs-built_in">medianBlur</span>(gray, median, <span class="hljs-number">5</span>);<br>cv::Mat diff = cv::<span class="hljs-built_in">abs</span>(median - gray);<br><br>cv::Mat tmp, min = gray.<span class="hljs-built_in">clone</span>();<br>min = <span class="hljs-number">255</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;kernel : kernels) &#123;<br>    cv::<span class="hljs-built_in">filter2D</span>(gray, tmp, <span class="hljs-number">-1</span>, kernel);<br>    cv::<span class="hljs-built_in">min</span>(min, cv::<span class="hljs-built_in">abs</span>(tmp), min);<br>&#125;<br><br>min.forEach&lt;<span class="hljs-type">uint8_t</span>&gt;([&amp;](<span class="hljs-type">uint8_t</span> &amp;pixel, <span class="hljs-type">const</span> <span class="hljs-type">int</span> *position) &#123;<br>    <span class="hljs-type">uint8_t</span> p = diff.<span class="hljs-built_in">at</span>&lt;<span class="hljs-type">uint8_t</span>&gt;(position[<span class="hljs-number">0</span>], position[<span class="hljs-number">1</span>]);<br>    <span class="hljs-keyword">if</span> (pixel &gt; conv_thr &amp;&amp; p &gt; filter_thr) &#123;<br>        count++;<br>    &#125;<br>&#125;);<br><br><span class="hljs-keyword">return</span> (<span class="hljs-type">float</span>) count / (<span class="hljs-type">float</span>) image.<span class="hljs-built_in">total</span>();<br></code></pre></td></tr></table></figure><p><img src="/img/2022-8-27%E8%A7%86%E9%A2%91%E8%AF%8A%E6%96%AD/cat01_salt.jpg" alt="雪花占比0.021147"><br><img src="/img/2022-8-27%E8%A7%86%E9%A2%91%E8%AF%8A%E6%96%AD/cat01_salt0.jpg" alt="雪花占比0.042087"><br><img src="/img/2022-8-27%E8%A7%86%E9%A2%91%E8%AF%8A%E6%96%AD/cat01_salt1.jpg" alt="雪花占比0.131752"></p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>视频质量诊断</tag>
      
      <tag>opencv</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>01背包 递归→记忆化搜索→动态规划</title>
    <link href="/2022/08/13/2022-8-13-01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <url>/2022/08/13/2022-8-13-01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h1><p>有一个背包，它的容量为C，现在有n种不同的物品，编号为0~~~n - 1，其中每件物品的重量（weight）为w(i),价值（value）为v(i)。问可以向这个背包中盛放哪些物品，使得在不超过背包容量的基础上，物品的总价值最大。</p><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>如果只用递归，相当于暴力解法，因为01背包问题相当于求n个物品的组合，使得这些物品能放进背包且物品的总价值最大。<br><br>那么一共有多少种组合呢，我们可以对每一件物品都进行选择放入背包或者不放入。n件物品，将有 2^n 种可能，组合之后还要计算出小于容量的组合，最后选出其中最大的，所以暴力递归的时间复杂度为 O((2^n) * n)。</p><h2 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h2><p>设定 F(n, C) 含义为：考虑将n个物品放入容量为C的背包，使得价值最大。可以得出：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">F(<span class="hljs-params">i</span>, <span class="hljs-params">c</span>)</span> = <span class="hljs-constructor">F(<span class="hljs-params">i</span> - 1, <span class="hljs-params">c</span>)</span>                  <br>        = v(i) + <span class="hljs-constructor">F(<span class="hljs-params">i</span> - 1, <span class="hljs-params">c</span> - <span class="hljs-params">w</span>(<span class="hljs-params">i</span>)</span>)<br></code></pre></td></tr></table></figure><p>当我们要放进 i 个物品进入容量为 c 的背包时，我们有两种策略：<br/><br>①、来了一个新的物品（i），但这个物品我们不需要放进背包。  <br/><br>②、来了一个新的物品（i），我们需要选择将它放进背包，所以此时的总价值需要加上当前的v(i)。而由于第 i 个物品已经放入背包中了，剩下的容量变为c - w（i）。  <br/><br>所以要求F(i, c)就是求出这两种策略的最大值，可以得出状态转移方程为：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">F(<span class="hljs-params">i</span>, <span class="hljs-params">c</span>)</span> = max(<span class="hljs-constructor">F(<span class="hljs-params">i</span> - 1, <span class="hljs-params">c</span>)</span>, v(i) + <span class="hljs-constructor">F(<span class="hljs-params">i</span> - 1, <span class="hljs-params">c</span> - <span class="hljs-params">w</span>(<span class="hljs-params">i</span>)</span>))<br></code></pre></td></tr></table></figure><p>这个状态转移方程是自顶向下的，可以写出递归的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Knapsack01</span>&#123;<br><br><span class="hljs-keyword">private</span>:<br><br>    <span class="hljs-comment">// 用 [0...index]的物品,填充容积为c的背包的最大价值</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bestValue</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;w, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;v, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> c)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(c &lt;= <span class="hljs-number">0</span> || index &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-type">int</span> res = <span class="hljs-built_in">bestValue</span>(w, v, index<span class="hljs-number">-1</span>, c);  <span class="hljs-comment">// 策略①</span><br>        <span class="hljs-keyword">if</span>(c &gt;= w[index])                       <span class="hljs-comment">// 策略②</span><br>            res = <span class="hljs-built_in">max</span>(res, v[index] + <span class="hljs-built_in">bestValue</span>(w, v, index - <span class="hljs-number">1</span>, c - w[index]));<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">knapsack01</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;w, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;v, <span class="hljs-type">int</span> C)</span></span>&#123;<br><br>        <span class="hljs-type">int</span> n = w.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span> || C == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">bestValue</span>(w, v, n - <span class="hljs-number">1</span>, C);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h1><p>递归存在太多重复计算，我们可以用一个数组记录计算过的结果:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 记忆化搜索</span><br><span class="hljs-comment">        时间复杂度: O(n * C) 其中n为物品个数; C为背包容积</span><br><span class="hljs-comment">        空间复杂度: O(n * C)</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Knapsack01</span>&#123;<br><br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; memo;<br><br>    <span class="hljs-comment">// 用 [0...index]的物品,填充容积为c的背包的最大价值</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bestValue</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;w, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;v, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> c)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(c &lt;= <span class="hljs-number">0</span> || index &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">if</span>(memo[index][c] != <span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">return</span> memo[index][c];<br><br>        <span class="hljs-type">int</span> res = <span class="hljs-built_in">bestValue</span>(w, v, index<span class="hljs-number">-1</span>, c);<br>        <span class="hljs-keyword">if</span>(c &gt;= w[index])<br>            res = <span class="hljs-built_in">max</span>(res, v[index] + <span class="hljs-built_in">bestValue</span>(w, v, index - <span class="hljs-number">1</span>, c - w[index]));<br>        memo[index][c] = res;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">knapsack01</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;w, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;v, <span class="hljs-type">int</span> C)</span></span>&#123;<br>        <span class="hljs-type">int</span> n = w.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span> || C == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        memo.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)<br>            memo.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(C + <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>));<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">bestValue</span>(w, v, n - <span class="hljs-number">1</span>, C);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>上面的都是自顶向下的思路，动态规划可以采用自底向上的方法来解决。<br/><br>背包问题的记忆是在一个二维数组中，我们可以创建一个dp[i][c]的二维数组，其中 i 表示我们考虑放入的是哪个物品，c表示背包的容量。下面举一个例子：背包的容量为5，可放入的物品如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">id</span>              <span class="hljs-number">0</span>               <span class="hljs-number">1</span>               <span class="hljs-number">2</span><br><span class="hljs-attribute">weight</span>          <span class="hljs-number">1</span>               <span class="hljs-number">2</span>               <span class="hljs-number">3</span><br><span class="hljs-attribute">value</span>           <span class="hljs-number">6</span>               <span class="hljs-number">10</span>              <span class="hljs-number">12</span><br></code></pre></td></tr></table></figure><p>可以创建数组：</p><table>  <tr>    <th> </th>    <th>0</th>    <th>1</th>    <th>2</th>    <th>3</th>    <th>4</th>    <th>5</th>  </tr>  <tr>    <td>0</td>    <td> </td>    <td> </td>    <td> </td>    <td> </td>    <td> </td>    <td> </td>  </tr>  <tr>    <td>1</td>    <td> </td>    <td> </td>    <td> </td>    <td> </td>    <td> </td>    <td> </td>  </tr>  <tr>    <td>2</td>    <td> </td>    <td> </td>    <td> </td>    <td> </td>    <td> </td>    <td> </td>  </tr></table><p>在数组的（2， 5）位置就是所要求的结果。<br/><br>下面先对第一行进行填充，第一行表示的就是当只有0号物品时，随背包容量增加是否将物品放入背包；由于只有0号物品，一定会放入背包的。数组的值就表示此时背包的最大价值。</p><table>  <tr>    <th> </th>    <th>0</th>    <th>1</th>    <th>2</th>    <th>3</th>    <th>4</th>    <th>5</th>  </tr>  <tr>    <td>0</td>    <td>0</td>    <td>6</td>    <td>6</td>    <td>6</td>    <td>6</td>    <td>6</td>  </tr>  <tr>    <td>1</td>    <td> </td>    <td> </td>    <td> </td>    <td> </td>    <td> </td>    <td> </td>  </tr>  <tr>    <td>2</td>    <td> </td>    <td> </td>    <td> </td>    <td> </td>    <td> </td>    <td> </td>  </tr></table><p>接下来考虑第一行：第一行所表达的含义是，当有 0 ，1 这两个物品时相对应的背包价值有什么变化；<br/><br>首先是（1， 0）位置，为0， 因为背包容量为0时放不进任何物品；（1， 1）位置为6，此时要考虑能否放进1号物品，不能放进的话照抄上面一行就行，由于容量为1，只能放进0号物品，所以为6；（1， 2）位置为10，此时要考虑是否将1号物品放入背包，当不放时结果就是（0， 2）的值为6，当决定要放1号物品时由于这时背包容量只有2，所以要加上当不考虑1号物品，容积为0的值，就是（0， 0）的值为0，所以最终结果为0 + 10与6的最大值，取10；剩下的（1， 3）也是同理，考虑不将1号物品放入背包时值依然是6， 考虑要放入1号物品时就要去看（0， 1）位置的值加上1号物品的值为6 + 10再与6比较，取16。后面依次计算比较即可。<br><br/><br>最后结果：</p><table>  <tr>    <th> </th>    <th>0</th>    <th>1</th>    <th>2</th>    <th>3</th>    <th>4</th>    <th>5</th>  </tr>  <tr>    <td>0</td>    <td>0</td>    <td>6</td>    <td>6</td>    <td>6</td>    <td>6</td>    <td>6</td>  </tr>  <tr>    <td>1</td>    <td>0</td>    <td>6</td>    <td>10</td>    <td>16</td>    <td>16</td>    <td>16</td>  </tr>  <tr>    <td>2</td>    <td>0</td>    <td>6</td>    <td>10</td>    <td>16</td>    <td>18</td>    <td>22</td>  </tr></table><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*动态规划</span><br><span class="hljs-comment">        时间复杂度: O(n * C) 其中n为物品个数; C为背包容积</span><br><span class="hljs-comment">        空间复杂度: O(n * C)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Knapsack01</span>&#123;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">knapsack01</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;w, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;v, <span class="hljs-type">int</span> C)</span></span>&#123;<br><br>        <span class="hljs-type">int</span> n = w.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span> || C == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">memo</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(C + <span class="hljs-number">1</span>,<span class="hljs-number">0</span>));<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt;= C ; j ++)<br>            memo[<span class="hljs-number">0</span>][j] = (j &gt;= w[<span class="hljs-number">0</span>] ? v[<span class="hljs-number">0</span>] : <span class="hljs-number">0</span> );<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; n ; i ++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt;= C ; j ++)&#123;<br>                memo[i][j] = memo[i<span class="hljs-number">-1</span>][j];      <span class="hljs-comment">// 策略1</span><br>                <span class="hljs-keyword">if</span>(j &gt;= w[i])                   <span class="hljs-comment">// 策略2</span><br>                    memo[i][j] = <span class="hljs-built_in">max</span>(memo[i][j], v[i] + memo[i - <span class="hljs-number">1</span>][j - w[i]]);<br>            &#125;<br>        <span class="hljs-keyword">return</span> memo[n - <span class="hljs-number">1</span>][C];<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>空间复杂度可以优化：</p><h2 id="Ⅰ"><a href="#Ⅰ" class="headerlink" title="Ⅰ"></a>Ⅰ</h2><p>对于状态转移方程：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">F(<span class="hljs-params">i</span>, <span class="hljs-params">c</span>)</span> = max(<span class="hljs-constructor">F(<span class="hljs-params">i</span> - 1, <span class="hljs-params">c</span>)</span>, v(i) + <span class="hljs-constructor">F(<span class="hljs-params">i</span> - 1, <span class="hljs-params">c</span> - <span class="hljs-params">w</span>(<span class="hljs-params">i</span>)</span>))<br></code></pre></td></tr></table></figure><p>第i行元素只依赖于i - 1行元素，理论上只需保持两行元素即可，可以将空间复杂度从O(n * C)-&gt;O(2 * C) = O(C)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Knapsack01</span>&#123;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">knapsack01</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;w, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;v, <span class="hljs-type">int</span> C)</span></span>&#123;<br><br>        <span class="hljs-type">int</span> n = w.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span> || C == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">memo</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(C + <span class="hljs-number">1</span>,<span class="hljs-number">0</span>));<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt;= C ; j ++)<br>            memo[<span class="hljs-number">0</span>][j] = (j &gt;= w[<span class="hljs-number">0</span>] ? v[<span class="hljs-number">0</span>] : <span class="hljs-number">0</span> );<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; n ; i ++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt;= C ; j ++)&#123;<br>                memo[i % <span class="hljs-number">2</span>][j] = memo[(i<span class="hljs-number">-1</span>) % <span class="hljs-number">2</span>][j];      <span class="hljs-comment">// 策略1</span><br>                <span class="hljs-keyword">if</span>(j &gt;= w[i])                             <span class="hljs-comment">// 策略2</span><br>                    memo[i % <span class="hljs-number">2</span>][j] = <span class="hljs-built_in">max</span>(memo[i % <span class="hljs-number">2</span>][j], v[i] + memo[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][j - w[i]]);<br>            &#125;<br>        <span class="hljs-keyword">return</span> memo[(n - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][C];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="Ⅱ"><a href="#Ⅱ" class="headerlink" title="Ⅱ"></a>Ⅱ</h2><p>还可以只使用一行大小为C的数组完成动态规划：当我们需要上一行的元素进行计算时，我们永远只需要待计算元素的上边和左边的元素就行，对于右面的元素不需要。那么就可以单行从右向左来刷新数组中的内容，直接看代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Knapsack01</span>&#123;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">knapsack01</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;w, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;v, <span class="hljs-type">int</span> C)</span></span>&#123;<br><br>        <span class="hljs-type">int</span> n = w.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span> || C == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">memo</span><span class="hljs-params">(C + <span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt;= C ; j ++)<br>            memo[j] = (j &gt;= w[<span class="hljs-number">0</span>] ? v[<span class="hljs-number">0</span>] : <span class="hljs-number">0</span> );<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; n ; i ++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = C ; j &gt;= w[i] ; j --)&#123;<br>                memo[j] = <span class="hljs-built_in">max</span>(memo[j], v[i] + memo[j - w[i]]);<br>            &#125;<br>        <span class="hljs-keyword">return</span> memo[C];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>泛型编程：C++</title>
    <link href="/2022/08/07/2022-8-7-C-%E6%A8%A1%E6%9D%BF/"/>
    <url>/2022/08/07/2022-8-7-C-%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h2 id="泛型编程"><a href="#泛型编程" class="headerlink" title="泛型编程"></a>泛型编程</h2><p>泛型编程就是将任意类型从程序设计中抽象出来。在面向过程编程中使用泛型编程就是用模板实现函数过程；在面向对象编程中使用模板就是用模板实现类。<br></p><h2 id="模板全特化"><a href="#模板全特化" class="headerlink" title="模板全特化"></a>模板全特化</h2><p>针对某一种特殊的场景。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; </span><br><span class="hljs-function">T <span class="hljs-title">add</span><span class="hljs-params">(T a, T b)</span> </span>&#123; <br>    <span class="hljs-keyword">return</span> a + b; <br>&#125; <br><br><span class="hljs-keyword">template</span>&lt;&gt; <br><span class="hljs-type">int</span> <span class="hljs-built_in">add</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) &#123; <br>    cout &lt;&lt; <span class="hljs-string">&quot;int template&quot;</span> &lt;&lt; endl; <br>    <span class="hljs-keyword">return</span> a + b; <br>&#125; <br></code></pre></td></tr></table></figure><h2 id="模板偏特化"><a href="#模板偏特化" class="headerlink" title="模板偏特化"></a>模板偏特化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt; <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123; <br><span class="hljs-keyword">public</span> : <br>    <span class="hljs-built_in">Test</span>() &#123; <br>        cout &lt;&lt; <span class="hljs-string">&quot;normal template&lt;T, U&gt;&quot;</span> &lt;&lt; endl; <br>    &#125; <br>&#125;; <br><br><span class="hljs-comment">// 全特化</span><br><span class="hljs-keyword">template</span>&lt;&gt; <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>&gt; &#123; <br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-built_in">Test</span>() &#123; <br>        cout &lt;&lt; <span class="hljs-string">&quot;specializion template&lt;int, double&gt;&quot;</span> &lt;&lt;endl; <br>    &#125; <br>&#125;; <br><br><span class="hljs-comment">// 偏特化 </span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&lt;<span class="hljs-type">int</span>, T&gt; &#123; <br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-built_in">Test</span>() &#123; <br>        cout &lt;&lt; <span class="hljs-string">&quot;particial template&lt;int, T&gt;&quot;</span> &lt;&lt;endl; <br>    &#125; <br>&#125;; <br><br><br><span class="hljs-comment">// 编译器调用全特化的优先级最高， 偏特化次之， 正常的调用最后</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Test&lt;string, <span class="hljs-type">int</span>&gt; t1;<br>    Test&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>&gt; t2;<br>    Test&lt;<span class="hljs-type">int</span>, string&gt; t3;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="可变参数模板"><a href="#可变参数模板" class="headerlink" title="可变参数模板"></a>可变参数模板</h2><p>ARGS表示模板中剩余部分的类型数量是可变的，但至少为一个。下面的例子能打印出传入的任意个数的参数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">(T a)</span> </span>&#123; cout &lt;&lt; a &lt;&lt; endl; &#125; <br> <br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> ...ARGS&gt; </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">(T a, ARGS... args)</span> </span>&#123; <br>    cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; <br>    <span class="hljs-built_in">Print</span>(args...); <br>&#125; <br></code></pre></td></tr></table></figure><p>要注意上面的void Print(T a)并不是偏特化，C++ 模板函数没有偏特化，只有全特化；上面的例子类似函数的重载。<br> <br></p><p>要求：实现一个能够分析传入参数类型的工具类,并能够在test函数对象中进行两个参数的加法运算：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> ... ARGS&gt; <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ARG</span> &#123; <br>    <span class="hljs-keyword">using</span> type = T; <br>    <span class="hljs-keyword">using</span> rest = ARG&lt;ARGS...&gt;; <br>&#125;; <br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ARG</span>&lt;T&gt; &#123; <br>    <span class="hljs-keyword">using</span> type = T; <br>&#125;; <br><br> <br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> ... ARGS&gt; <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123; <br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-function">T <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">typename</span> ARG&lt;ARGS...&gt;::type a, <span class="hljs-keyword">typename</span> ARG&lt;ARGS...&gt;::rest::type b)</span> </span>&#123; <br>        <span class="hljs-keyword">return</span> a + b; <br>    &#125; <br>&#125;; <br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;    <br>    Test&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; t1; <br>    Test&lt;<span class="hljs-type">double</span>, <span class="hljs-type">double</span>, <span class="hljs-type">int</span>&gt; t2; <br>    cout &lt;&lt; <span class="hljs-built_in">t1</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>) &lt;&lt; endl;       <span class="hljs-comment">// 7</span><br>    cout &lt;&lt; <span class="hljs-built_in">t2</span>(<span class="hljs-number">3.5</span>, <span class="hljs-number">4</span>) &lt;&lt; endl;     <span class="hljs-comment">// 7.5</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125; <br></code></pre></td></tr></table></figure><p>如果想像这样用test函数对象： <br><br>Test&lt;int(int, int)&gt; t1; <br><br>可以把test类改成下面这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> ... ARGS&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>; <br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> ... ARGS&gt; <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&lt;<span class="hljs-built_in">T</span>(ARGS...)&gt; &#123; <br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-function">T <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">typename</span> ARG&lt;ARGS...&gt;::type a, <span class="hljs-keyword">typename</span> ARG&lt;ARGS...&gt;::rest::type b)</span> </span>&#123; <br>        <span class="hljs-keyword">return</span> a + b; <br>    &#125; <br>&#125;; <br></code></pre></td></tr></table></figure><p>如果初始化的参数个数大于三个时，上面的程序只会用到前三个，下面实现当初始化参数大于三个直接报错。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> ... ARGS&gt; <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ARG</span> &#123; <br>    <span class="hljs-keyword">using</span> type = T; <br>    <span class="hljs-keyword">using</span> rest = ARG&lt;ARGS...&gt;; <br>&#125;; <br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ARG</span>&lt;T&gt; &#123; <br>    <span class="hljs-keyword">using</span> type = T; <br>    <span class="hljs-keyword">using</span> finaltype = T;        <span class="hljs-comment">// 最后一个参数类型</span><br>&#125;; <br><br> <br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> ... ARGS&gt; <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123; <br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-function">T <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">typename</span> ARG&lt;ARGS...&gt;::type a, <span class="hljs-keyword">typename</span> ARG&lt;ARGS...&gt;::rest::finaltype b)</span> </span>&#123;         <span class="hljs-comment">// 将type改为finaltype</span><br>        <span class="hljs-keyword">return</span> a + b; <br>    &#125; <br>&#125;; <br></code></pre></td></tr></table></figure><h2 id="模板可以传入编译期的常量"><a href="#模板可以传入编译期的常量" class="headerlink" title="模板可以传入编译期的常量"></a>模板可以传入编译期的常量</h2><p>下面的代码可以打印出“10”到“1”：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span> M&gt; </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span> </span>&#123; <br>    cout &lt;&lt; M &lt;&lt; <span class="hljs-string">&quot;,&quot;</span>; <br>    <span class="hljs-built_in">Print</span>&lt;M - <span class="hljs-number">1</span>&gt;(); <br>&#125; <br><br><span class="hljs-keyword">template</span>&lt;&gt; <br><span class="hljs-type">void</span> <span class="hljs-built_in">Print</span>&lt;<span class="hljs-number">1</span>&gt;() &#123; <br>    cout &lt;&lt; <span class="hljs-string">&quot;1&quot;</span> &lt;&lt; endl; <br>&#125; <br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">Print</span>&lt;<span class="hljs-number">10</span>&gt;();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="其他例子"><a href="#其他例子" class="headerlink" title="其他例子"></a>其他例子</h2><p>求1~任意数的和：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span> M&gt; <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sum</span> &#123; <br>    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> r = sum&lt;M - <span class="hljs-number">1</span>&gt;::r + M; <br>&#125;; <br><br><span class="hljs-keyword">template</span>&lt;&gt; <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sum</span>&lt;<span class="hljs-number">1</span>&gt; &#123; <br>    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> r = <span class="hljs-number">1</span>; <br>&#125;; <br><br><span class="hljs-comment">// 求1~5的和</span><br><span class="hljs-comment">// cout &lt;&lt; sum&lt;5&gt;::r ;</span><br></code></pre></td></tr></table></figure><br><p>判断一个数是否是偶数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span> N&gt; <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">YES_OR_NO</span> &#123; <br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span>* r; <br>&#125;; <br><br><span class="hljs-keyword">template</span>&lt;&gt; <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">YES_OR_NO</span>&lt;<span class="hljs-number">0</span>&gt; &#123; <br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span>* r; <br>&#125;; <br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span> N&gt; <br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *YES_OR_NO&lt;N&gt;::r = <span class="hljs-string">&quot;yes&quot;</span>; <br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *YES_OR_NO&lt;<span class="hljs-number">0</span>&gt;::r = <span class="hljs-string">&quot;no&quot;</span>; <br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span> N&gt; <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_even</span> &#123; <br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *r; <br>&#125;; <br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span> N&gt; <br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *is_even&lt;N&gt;::r = YES_OR_NO&lt;!(N % <span class="hljs-number">2</span>)&gt;::r; <br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; is_even&lt;<span class="hljs-number">5</span>&gt;::r &lt;&lt; endl; <span class="hljs-comment">// no </span><br>    cout &lt;&lt; is_even&lt;<span class="hljs-number">6</span>&gt;::r &lt;&lt; endl; <span class="hljs-comment">// yes </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++-const</title>
    <link href="/2022/08/07/2022-8-7-C-const/"/>
    <url>/2022/08/07/2022-8-7-C-const/</url>
    
    <content type="html"><![CDATA[<p>最近做题时发现提交下面的代码出现报错：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;string&gt; ret;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(string &amp;digits, <span class="hljs-type">int</span> index, string &amp;s)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (index == digits.<span class="hljs-built_in">size</span>()) &#123;<br>        ret.<span class="hljs-built_in">push_back</span>(s);<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-type">char</span> c = digits[index];<br>    string letter = letterMap[c - <span class="hljs-string">&#x27;0&#x27;</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; letter.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-built_in">dfs</span>(digits, index + <span class="hljs-number">1</span>, s + letter[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>报错：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">Line <span class="hljs-number">24</span>: Char <span class="hljs-number">36</span>: error: non-<span class="hljs-type">const</span> lvalue reference to type <span class="hljs-string">&#x27;basic_string&lt;...&gt;&#x27;</span> cannot bind to a temporary of type <span class="hljs-string">&#x27;basic_string&lt;...&gt;&#x27;</span><br>            <span class="hljs-built_in">dfs</span>(digits, index + <span class="hljs-number">1</span>, s + letter[i]);<br>                                   ^~~~~~~~~~~~~<br>Line <span class="hljs-number">16</span>: Char <span class="hljs-number">49</span>: note: passing argument to parameter <span class="hljs-string">&#x27;s&#x27;</span> <span class="hljs-function">here</span><br><span class="hljs-function">    <span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(string &amp;digits, <span class="hljs-type">int</span> index, string &amp;s)</span> </span>&#123;<br>                                                ^<br></code></pre></td></tr></table></figure><br><p>在传入参数string &amp;s前加一个const就能通过。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(string &amp;digits, <span class="hljs-type">int</span> index, <span class="hljs-type">const</span> string &amp;s)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (index == digits.<span class="hljs-built_in">size</span>()) &#123;<br>        ret.<span class="hljs-built_in">push_back</span>(s);<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-type">char</span> c = digits[index];<br>    string letter = letterMap[c - <span class="hljs-string">&#x27;0&#x27;</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; letter.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-built_in">dfs</span>(digits, index + <span class="hljs-number">1</span>, s + letter[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以查了一下const的用法看看是什么原因。</p><h1 id="const的常见用法"><a href="#const的常见用法" class="headerlink" title="const的常见用法"></a>const的常见用法</h1><h2 id="修饰普通类型的变量"><a href="#修饰普通类型的变量" class="headerlink" title="修饰普通类型的变量"></a>修饰普通类型的变量</h2><p>const修饰普通类型的变量后该变量会被编译器认为是一个常量，其值不允许修改。尽管可以通过取变量的地址并对该地址内的值进行赋值，但编译后变量的值仍然不会改变，因为编译器会对const修饰的变量进行优化。<br></p><h2 id="修饰指针变量"><a href="#修饰指针变量" class="headerlink" title="修饰指针变量"></a>修饰指针变量</h2><p>const修饰指针指向的内容，则内容为不可变量;修饰指针，则指针为不可变量。<br></p><h2 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h2><p>①、值传递的const修饰传递，一般这种情况不需要const修饰，因为函数会自动产生临时变量复制实参值。<br><br>②、当const参数为指针时，可以防止指针被意外篡改。<br><br>③、自定义类型的参数传递，需要临时对象复制参数，对于临时对象的构造，需要调用构造函数，比较浪费时间，因此我们采取const外加引用传递的方法。<br></p><h2 id="修饰类成员函数"><a href="#修饰类成员函数" class="headerlink" title="修饰类成员函数"></a>修饰类成员函数</h2><p>const修饰类成员函数，其目的是防止成员函数修改被调用对象的值，如果我们不想修改一个调用对象的值，所有的成员函数都应当声明为 const 成员函数。<br></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这时再看提交报的错误， 当string&amp;类型的参数传入时，函数的形参为非const类型，而一个参数以非const传入，编译器一般会认为程序员会在该函数里修改该参数，而且该参数返回后还会发挥作用。此时如果你把一个临时变量当成非const引用传进来，由于临时变量的特殊性，程序员无法对改临时变量进行操作，同时临时变量可能随时会消失，修改临时变量也毫无意义，因此，临时变量不能作为非const引用。</p><h1 id="其他要注意的"><a href="#其他要注意的" class="headerlink" title="其他要注意的"></a>其他要注意的</h1><h2 id="const放置的位置"><a href="#const放置的位置" class="headerlink" title="const放置的位置"></a>const放置的位置</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span> greeting[] = <span class="hljs-string">&quot;Hello&quot;</span>;<br><span class="hljs-type">char</span> *p = greeting;                 <span class="hljs-comment">// non-const pointer, non-const data</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *p = greeting;           <span class="hljs-comment">// non-const pointer, const data</span><br><span class="hljs-type">char</span> * <span class="hljs-type">const</span> p = greeting;          <span class="hljs-comment">// const pointer, non-const data</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-type">const</span> p = greeting;    <span class="hljs-comment">// const pointer, const data</span><br></code></pre></td></tr></table></figure><br/><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-type">const</span> Widget *pw)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f2</span><span class="hljs-params">(Widget <span class="hljs-type">const</span> *pw)</span></span>;  <span class="hljs-comment">// 两个都是一样的，函数获得一个指针，指向一个常量Widget对象</span><br></code></pre></td></tr></table></figure><h2 id="STL里的const"><a href="#STL里的const" class="headerlink" title="STL里的const"></a>STL里的const</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>...<br><span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;::iterator iter = vec.<span class="hljs-built_in">begin</span>();<br>*iter = <span class="hljs-number">10</span>;         <span class="hljs-comment">// 正确</span><br>++iter;             <span class="hljs-comment">// 错误， iter为const</span><br><br>vector&lt;<span class="hljs-type">int</span>&gt;::const_iterator cIter = vec.<span class="hljs-built_in">begin</span>();<br>*cIter = <span class="hljs-number">10</span>;        <span class="hljs-comment">// 错误， *cIter为const</span><br>++cIter;            <span class="hljs-comment">// 正确</span><br></code></pre></td></tr></table></figure><p><br> 参考：<a href="https://www.runoob.com/w3cnote/cpp-const-keyword.html">https://www.runoob.com/w3cnote/cpp-const-keyword.html</a></p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++的继承与多态</title>
    <link href="/2022/07/31/2022-7-31-C-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/"/>
    <url>/2022/07/31/2022-7-31-C-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/</url>
    
    <content type="html"><![CDATA[<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>1、基类给所有派生类提供公共的属性（成员变量）和方法（成员函数），通过继承达到代码复用的目的。<br><br>2、基类可以给所有的派生类提供统一的虚函数接口，派生类通过函数重写，达到多态调用的目的。<br></p><h2 id="派生类对象的构造过程"><a href="#派生类对象的构造过程" class="headerlink" title="派生类对象的构造过程"></a>派生类对象的构造过程</h2><p>必须通过调用基类的构造函数来初始化基类继承来的成员。</p><h2 id="重载、隐藏、覆盖"><a href="#重载、隐藏、覆盖" class="headerlink" title="重载、隐藏、覆盖"></a>重载、隐藏、覆盖</h2><p>基类和派生类中，可以定义同名的成员，包括成员变量和成员函数。派生类从基类继承来的成员，都带有基类的作用域，作用域不同，名字相同的成员不会冲突。<br></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> <br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base</span>(<span class="hljs-type">int</span> data) : <span class="hljs-built_in">m_a</span>(data) &#123; cout &lt;&lt; <span class="hljs-string">&quot;Base()&quot;</span> &lt;&lt; endl; &#125;<br>    ~<span class="hljs-built_in">Base</span>() &#123; cout &lt;&lt;<span class="hljs-string">&quot;~Base()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base::show()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base::show(int)&quot;</span> &lt;&lt; endl; &#125;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">int</span> m_a;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derive</span> : <span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Derive</span>(<span class="hljs-type">int</span> data) : <span class="hljs-built_in">Base</span>(data) &#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive()&quot;</span> &lt;&lt; endl; &#125;<br>    ~<span class="hljs-built_in">Derive</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;~Derive()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive::show()&quot;</span> &lt;&lt; endl; &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> m_b;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Derive <span class="hljs-title">d</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    d.<span class="hljs-built_in">show</span>();       <span class="hljs-comment">// 调用子类自己的show方法</span><br>    d.Base::<span class="hljs-built_in">show</span>(); <span class="hljs-comment">// 指定了作用域，调用子类从基类继承来的show方法</span><br>    <span class="hljs-comment">// d.show(10);  // 编译错误， 子类的show方法把基类继承来的show方法隐藏了</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><p>一组函数在同一作用域中，函数名相同，参数列表不同，才能叫函数重载。上面的Base::show()和Base::show(int)是重载函数；Base::show(int)和Derive::show()不是。</p><h4 id="隐藏"><a href="#隐藏" class="headerlink" title="隐藏"></a>隐藏</h4><p>基类和子类中的同名成员，只要成员名字相同，用子类对象调用该成员名字时，就发生了隐藏（隐藏了基类的同名成员），子类默认调用的都是自己的成员，除非加上作用域。</p><h4 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a>覆盖</h4><p>基类和子类的同名成员函数，不仅函数名字相同，返回值相同，参数列表也相同，而且基类的该函数是virtual虚函数，子类的同名方法自动被处理为虚函数，它们之间的关系就是覆盖。覆盖主要指虚函数表中函数地址的覆盖重写。<br></p><h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Animal</span>(<span class="hljs-type">const</span> string &amp;name) : __name(name) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt;<span class="hljs-string">&quot;I do not know&quot;</span> &lt;&lt; endl; &#125;<br><span class="hljs-keyword">protected</span>:<br>    string __name;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> : <span class="hljs-keyword">public</span> Animal<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Cat</span>() : <span class="hljs-built_in">Animal</span>(<span class="hljs-string">&quot;cat&quot;</span>) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;I can run&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Cat a;<br>    Animal &amp;b = a;<br>    Animal *c = &amp;a;<br>    a.<span class="hljs-built_in">run</span>();<br>    b.<span class="hljs-built_in">run</span>();<br>    c-&gt;<span class="hljs-built_in">run</span>();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">I can <span class="hljs-built_in">run</span><br>I <span class="hljs-keyword">do</span> <span class="hljs-keyword">not</span> know<br>I <span class="hljs-keyword">do</span> <span class="hljs-keyword">not</span> know<br></code></pre></td></tr></table></figure><p>虽然用基类指向子类，但仍然会调用基类的方法，如果基类不对run()方法进行实现，编译会报错。<br><br>普通的成员方法是跟着类走的，为了解决这种现象，可以使用virtual。虚函数是跟着对象走的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Animal</span>(<span class="hljs-type">const</span> string &amp;name) : __name(name) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt;<span class="hljs-string">&quot;I do not know&quot;</span> &lt;&lt; endl; &#125;<br><span class="hljs-keyword">protected</span>:<br>    string __name;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> : <span class="hljs-keyword">public</span> Animal<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Cat</span>() : <span class="hljs-built_in">Animal</span>(<span class="hljs-string">&quot;cat&quot;</span>) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;I can run&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Cat a;<br>    Animal &amp;b = a;<br>    Animal *c = &amp;a;<br>    a.<span class="hljs-built_in">run</span>();<br>    b.<span class="hljs-built_in">run</span>();<br>    c-&gt;<span class="hljs-built_in">run</span>();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">I can <span class="hljs-built_in">run</span><br>I can <span class="hljs-built_in">run</span><br>I can run<br></code></pre></td></tr></table></figure><p>普通的成员方法是编译期的，虚函数是在运行时的。  </p><p>多态指的是，用基类指针（引用）指向从它继承的一组派生类对象，调用派生类的同名覆盖方法，基类指针指向哪个派生类对象，就会调用相应派生类对象的同名覆盖方法。</p><h3 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h3><p>当基类的析构函数不是虚函数时，如果基类指针指向堆上的子类对象，释放资源的时候使用delete p操作时就会静态绑定基类的析构函数，子类的析构函数没机会调用，会造成内存泄漏。</p><h3 id="析构函数可以是纯虚函数吗？"><a href="#析构函数可以是纯虚函数吗？" class="headerlink" title="析构函数可以是纯虚函数吗？"></a>析构函数可以是纯虚函数吗？</h3><p>先来看普通的虚析构函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>  <br>&#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-built_in">Base</span>()&#123;&#125;  <br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base</span>()&#123;&#125;  <br>&#125;;  <br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span>: <span class="hljs-keyword">public</span> Base  <br>&#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-built_in">Derived</span>()&#123;&#125;;  <br>    ~<span class="hljs-built_in">Derived</span>()&#123;&#125;;  <br>&#125;  <br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span>  </span><br><span class="hljs-function"></span>&#123;  <br>   Base *pb;  <br>   pb = <span class="hljs-keyword">new</span> Derived;  <br>   <span class="hljs-keyword">delete</span> pb;  <br>&#125; <br></code></pre></td></tr></table></figure><p>上面的代码运行时会发生动态绑定，会先调用Derived的析构函数，然后再调用Base的析构函数；<br>如果基类的析构函数不加virtual，delete pb只会执行Base的析构函数，造成子类没有被析构，内存泄漏。<br>如果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>  <br>&#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-built_in">Base</span>()&#123;&#125;  <br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base</span>()= <span class="hljs-number">0</span>;  <br>&#125;; <br></code></pre></td></tr></table></figure><p>这样会编译错误，因为Derived的析构函数隐含了Base的析构函数，而virtual ~Base()= 0; 会导致找不到基类的析构函数。<br>我们完全可以为纯虚函数指定函数体，纯虚函数并不是不能定义函数体，而是表明这个类变成了抽象类，不能产生对象。<br>所以可以改成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>  <br>&#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-built_in">Base</span>()&#123;&#125;  <br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base</span>() = <span class="hljs-number">0</span>; <span class="hljs-comment">//pure virtual  </span><br>&#125;;  <br>Base::~<span class="hljs-built_in">Base</span>()<span class="hljs-comment">//function body  </span><br>&#123;  <br>&#125;  <br></code></pre></td></tr></table></figure><h3 id="哪些函数不能带有virtual"><a href="#哪些函数不能带有virtual" class="headerlink" title="哪些函数不能带有virtual"></a>哪些函数不能带有virtual</h3><p>1、inline<br>内联函数是指在编译期间被调用函数体本身来代替函数的调用指令，但虚函数的多态需要在运行时根据对象的类型才知道调用哪个虚函数，所以没法在编译时进行内联函数展开。<br>2、static<br>static成员没有this指针。virtual函数⼀定要通过对象来调⽤，有隐藏的this指针。<br>3、构造函数<br>在构造函数中调⽤虚函数，实际执⾏的是⽗类的对应函数，因为⾃⼰还没有构造好，这时多态失效。  </p><h3 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h3><p>虚继承可以使子类中只保留一份间接基类的成员。</p><h3 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h3><p>如果对象内有虚函数，则在这个对象占用的存储区的前八个字节为一个地址，该地址会指向一个虚函数表（vtable），里面存放虚函数的地址。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base</span>() &#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> x;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> x;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;sizeof (Base) = &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(Base) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;sizeof (A)    = &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(A) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;sizeof (B)    = &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(B) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">sizeof (Base) <span class="hljs-operator">=</span> <span class="hljs-number">8</span><br>sizeof (A)    <span class="hljs-operator">=</span> <span class="hljs-number">16</span><br>sizeof (B)    <span class="hljs-operator">=</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>需要注意Base类和A类存储的虚函数表的地址是不一样的。相同对象指向的虚函数表是同一个虚函数表。若子类重写了虚函数，则在子类的虚函数表中把基类继承来的虚函数的地址覆盖掉。<br><br>虚函数表可以看做存储函数地址的数组,可以通过下面方法直接访问虚函数表中的地址并执行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Base func1&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Base func2&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func3</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Base func3&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base</span>()&#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;A func2&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-type">int</span> x;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(*func)</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>; <span class="hljs-comment">// 函数指针类型</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    A a;<br>    ((func **)(&amp;a))[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]();<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">A</span> func2<br></code></pre></td></tr></table></figure><p>((func **)(&amp;a))[0]是虚函数表的地址，上面代码是取其第二个地址即func2()并执行。<br></p><h4 id="需要注意的地方"><a href="#需要注意的地方" class="headerlink" title="需要注意的地方"></a>需要注意的地方</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; <span class="hljs-string">&quot; : class Base : &quot;</span> &lt;&lt; x &lt;&lt; endl;<br>    &#125;<br>    <br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base</span>()&#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; <span class="hljs-string">&quot; : class A : &quot;</span> &lt;&lt; x &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-type">int</span> x;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(*func)</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>; <span class="hljs-comment">// 函数指针类型</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    A a;<br>    a.<span class="hljs-built_in">func</span>(<span class="hljs-number">123</span>);                <span class="hljs-comment">// ①</span><br>    ((func **)(&amp;a))[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>](<span class="hljs-number">123</span>); <span class="hljs-comment">// ②</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-number">0x7ffdcf2cfbf0</span> : <span class="hljs-keyword">class</span> <span class="hljs-symbol">A</span> : <span class="hljs-symbol">123</span><br><span class="hljs-symbol">0x7b</span> : <span class="hljs-symbol">class</span> <span class="hljs-symbol">A</span> : <span class="hljs-symbol">0</span><br></code></pre></td></tr></table></figure><p>C/C++的成员函数的传入参数有一个隐藏的this指针（且为第一个参数），此时②会将“123”传给默认的this，所以从输出结果来看：“0x7b”的值就是“123”。<br><br>程序改成这样就能正常了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(*func)</span><span class="hljs-params">(<span class="hljs-type">void</span>*, <span class="hljs-type">int</span>)</span></span>; <span class="hljs-comment">// 函数指针类型</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    A a;<br>    a.<span class="hljs-built_in">func</span>(<span class="hljs-number">123</span>);<br>    ((func **)(&amp;a))[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>](&amp;a, <span class="hljs-number">123</span>);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言中的变量</title>
    <link href="/2022/07/24/2022-7-24-C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%E7%9B%B8%E5%85%B3%E7%9A%84%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/07/24/2022-7-24-C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%E7%9B%B8%E5%85%B3%E7%9A%84%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="C的内存区域"><a href="#C的内存区域" class="headerlink" title="C的内存区域"></a>C的内存区域</h2><ol><li><p>内存栈区： 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等；<br></p></li><li><p>内存堆区： 存放new或者malloc出来的对象,一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收；<br></p></li><li><p>常数区： 存放局部变量或者全局变量的值；<br></p></li><li><p>静态区： 用于存放全局变量或者静态变量,编译器编译时即分配内存。全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域（RW）， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域（ZI）。程序结束后由系统释放；<br></p></li><li><p>代码区：二进制代码。<br></p></li></ol><h2 id="C变量的存储"><a href="#C变量的存储" class="headerlink" title="C变量的存储"></a>C变量的存储</h2><h5 id="变量的存储类型取决于它声明的位置："><a href="#变量的存储类型取决于它声明的位置：" class="headerlink" title="变量的存储类型取决于它声明的位置："></a>变量的存储类型取决于它声明的位置：</h5><p>1、凡是在任何代码块之外声明的变量总是存储在静态内存中。不属于堆栈内存，这类变量称为静态变量。静态变量在函数运行之前创建。 <br></p><p>2、在代码块内部声明的变量的存储类型是自动的，存储在堆栈中。<br></p><p>3、对于在代码块内部声明的变量，如果给它加上 static 关键字，可以使它的存储类型由自动转变为静态。具有静态存储类型的变量在整个执行过程中一直存在。而不仅仅是它所在的代码块执行的时候存在。 <br></p><h2 id="变量的初始化"><a href="#变量的初始化" class="headerlink" title="变量的初始化"></a>变量的初始化</h2><h5 id="如果不显式的初始化，静态变量的初始化为0；"><a href="#如果不显式的初始化，静态变量的初始化为0；" class="headerlink" title="如果不显式的初始化，静态变量的初始化为0； "></a>如果不显式的初始化，静态变量的初始化为0； <br></h5><h5 id="而自动变量是不做任何初始化的，是随机值。"><a href="#而自动变量是不做任何初始化的，是随机值。" class="headerlink" title="而自动变量是不做任何初始化的，是随机值。 "></a>而自动变量是不做任何初始化的，是随机值。 <br></h5><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><h5 id="当我们同时编译多个文件时，所有未加-static-前缀的全局变量和函数都具有全局可见性。"><a href="#当我们同时编译多个文件时，所有未加-static-前缀的全局变量和函数都具有全局可见性。" class="headerlink" title="当我们同时编译多个文件时，所有未加 static 前缀的全局变量和函数都具有全局可见性。"></a>当我们同时编译多个文件时，所有未加 static 前缀的全局变量和函数都具有全局可见性。</h5><h5 id="存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和-static-变量，只不过和全局变量比起来，static-可以控制变量的可见范围。"><a href="#存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和-static-变量，只不过和全局变量比起来，static-可以控制变量的可见范围。" class="headerlink" title="存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和 static 变量，只不过和全局变量比起来，static 可以控制变量的可见范围。"></a>存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和 static 变量，只不过和全局变量比起来，static 可以控制变量的可见范围。</h5><h5 id="当-static-修饰全局变量或函数时，其变量存储类型和作用域都不变，只改变它的链接属性，将外部链接改为内部链接。也就是说变量或者函数只能在当前源文件中访问，而不能在其他源文件中访问。"><a href="#当-static-修饰全局变量或函数时，其变量存储类型和作用域都不变，只改变它的链接属性，将外部链接改为内部链接。也就是说变量或者函数只能在当前源文件中访问，而不能在其他源文件中访问。" class="headerlink" title="当 static 修饰全局变量或函数时，其变量存储类型和作用域都不变，只改变它的链接属性，将外部链接改为内部链接。也就是说变量或者函数只能在当前源文件中访问，而不能在其他源文件中访问。"></a>当 static 修饰全局变量或函数时，其变量存储类型和作用域都不变，只改变它的链接属性，将外部链接改为内部链接。也就是说变量或者函数只能在当前源文件中访问，而不能在其他源文件中访问。<br></h5><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>①在C++中static修饰类的成员属性： 类中加了static关键字的变量永远只有一份，如果对其值进行修改，其他位置对其访问就是修改后的值。但要注意需要在类内定义，类外初始化。<br><br>C++中static修饰类的成员属性可以用于单例模式的实现，可以看这篇 <a href="https://tthres.github.io/posts/C++-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/">https://tthres.github.io/posts/C++-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</a> 的介绍。<br><br>②static修饰成员函数： 加了static的成员方法与普通的成员方法最大的区别就是不能访问this指针。 在static里的类方法的变量一定要static修饰过的，否则报错（即在该函数里只能访问静态成员） ，不需要生成对象就能访问该函数。（单例模式中的getInstance）<br></p><p>③static修饰普通变量和函数： 变量：变成存在静态区，main函数运行前就初始化了，在定义该变量的文件内才能使用; 函数：表明了作用范围，仅在定义该函数的文件内才能使用。<br></p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++-单例模式</title>
    <link href="/2022/07/23/2022-7-23-C-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/07/23/2022-7-23-C-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式指的是，无论怎么获取，永远只能得到该类类型的唯一一个实例对象，要实现一个单例必须要满足三个条件：</p><p>① 构造函数私有化，这样用户就不能任意定义该类型的对象了 <br><br>② 定义该类型唯一的对象 <br><br>③ 通过一个static静态成员方法返回唯一的对象实例 <br></p><h3 id="单例的优点"><a href="#单例的优点" class="headerlink" title="单例的优点"></a>单例的优点</h3><p>单例模式会阻止其他对象实例化其自己的单例对象的副本，从而确保所有对象都访问唯一实例。<br><br>因为类控制了实例化过程，所以类可以灵活更改实例化过程。<br><br>易于控制对象实例化的个数进而节约系统资源。<br></p><h2 id="单例模式的实现"><a href="#单例模式的实现" class="headerlink" title="单例模式的实现"></a>单例模式的实现</h2><h3 id="根据进行对象的实例化的时间，可以将单例模式分为饿汉式和懒汉式"><a href="#根据进行对象的实例化的时间，可以将单例模式分为饿汉式和懒汉式" class="headerlink" title="根据进行对象的实例化的时间，可以将单例模式分为饿汉式和懒汉式 "></a>根据进行对象的实例化的时间，可以将单例模式分为饿汉式和懒汉式 <br></h3><h3 id="饿汉式单例模式"><a href="#饿汉式单例模式" class="headerlink" title="饿汉式单例模式"></a>饿汉式单例模式</h3><p>在程序启动时就将单例对象进行实例化，如果运行过程中没用使用到该实例对象，将会产生浪费。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">static</span> Singleton* <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> &amp;single;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">static</span> Singleton single;<br><br><span class="hljs-built_in">Singleton</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;Singleton()&quot;</span> &lt;&lt; endl; &#125;<br>~<span class="hljs-built_in">Singleton</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;~Singleton()&quot;</span> &lt;&lt; endl; &#125;<br><br><span class="hljs-built_in">Singleton</span>(<span class="hljs-type">const</span> Singleton&amp;); <span class="hljs-comment">// 防止外部使用拷贝构造产生新的对象   </span><br><br>&#125;;<br><br>Singleton Singleton::single;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Singleton *p1 = Singleton::<span class="hljs-built_in">getInstance</span>();<br>Singleton *p2 = Singleton::<span class="hljs-built_in">getInstance</span>();<br>Singleton *p3 = Singleton::<span class="hljs-built_in">getInstance</span>();<br>cout&lt;&lt;p1&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;p2&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;p3&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">Singleton</span>()<br><span class="hljs-number">0</span>x55ef33473151 <span class="hljs-number">0</span>x55ef33473151 <span class="hljs-number">0</span>x55ef33473151<br>~<span class="hljs-built_in">Singleton</span>()<br></code></pre></td></tr></table></figure><h3 id="懒汉式单例模式"><a href="#懒汉式单例模式" class="headerlink" title="懒汉式单例模式"></a>懒汉式单例模式</h3><p>在第一次使用单例对象时，才对对象进行初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">static</span> Singleton* <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">if</span> (single == <span class="hljs-literal">nullptr</span>) &#123;<br>single = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Singleton</span>();<br>&#125;<br><span class="hljs-keyword">return</span> single;<br>&#125;<br>    ~<span class="hljs-built_in">Singleton</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;~Singleton()&quot;</span> &lt;&lt; endl; &#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">static</span> Singleton *single;<br><br><span class="hljs-built_in">Singleton</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;Singleton()&quot;</span> &lt;&lt; endl; &#125;<br><br><span class="hljs-built_in">Singleton</span>(<span class="hljs-type">const</span> Singleton&amp;);<br>&#125;;<br><br>Singleton* Singleton::single = <span class="hljs-literal">nullptr</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Singleton *p1 = Singleton::<span class="hljs-built_in">getInstance</span>();<br>Singleton *p2 = Singleton::<span class="hljs-built_in">getInstance</span>();<br>Singleton *p3 = Singleton::<span class="hljs-built_in">getInstance</span>();<br>cout &lt;&lt; p1 &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; p2 &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; p3 &lt;&lt; endl;<br>    <span class="hljs-keyword">delete</span> p1;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">Singleton</span>()<br><span class="hljs-number">0</span>x555cce3feeb0 <span class="hljs-number">0</span>x555cce3feeb0 <span class="hljs-number">0</span>x555cce3feeb0<br>~<span class="hljs-built_in">Singleton</span>()<br></code></pre></td></tr></table></figure><h4 id="上面懒汉式的单例模式代码中写了delete-p1-一般会有多个指针指向实例化的对象，可能会出现忘记写delete或多次delete的情况，我利用static静态对象在程序结束时自动析构的特性改进了一下："><a href="#上面懒汉式的单例模式代码中写了delete-p1-一般会有多个指针指向实例化的对象，可能会出现忘记写delete或多次delete的情况，我利用static静态对象在程序结束时自动析构的特性改进了一下：" class="headerlink" title="上面懒汉式的单例模式代码中写了delete p1; 一般会有多个指针指向实例化的对象，可能会出现忘记写delete或多次delete的情况，我利用static静态对象在程序结束时自动析构的特性改进了一下："></a>上面懒汉式的单例模式代码中写了delete p1; 一般会有多个指针指向实例化的对象，可能会出现忘记写delete或多次delete的情况，我利用static静态对象在程序结束时自动析构的特性改进了一下：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">static</span> Singleton* <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">if</span> (single == <span class="hljs-literal">nullptr</span>) &#123;<br>single = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Singleton</span>();<br>&#125;<br><span class="hljs-keyword">return</span> single;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">static</span> Singleton *single;<br><br>    <span class="hljs-built_in">Singleton</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;Singleton()&quot;</span> &lt;&lt; endl; &#125;<br>~<span class="hljs-built_in">Singleton</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;~Singleton()&quot;</span> &lt;&lt; endl; &#125;<br><br>    <span class="hljs-built_in">Singleton</span>(<span class="hljs-type">const</span> Singleton&amp;);<br><br><span class="hljs-comment">// 定义一个嵌套类，在该类的析构函数中，自动释放外层类的资源</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CRelease</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>~<span class="hljs-built_in">CRelease</span>() &#123; <span class="hljs-keyword">delete</span> single; &#125;<br>&#125;;<br><span class="hljs-comment">// 通过该静态对象在程序结束时自动析构的特点，来释放外层类的对象资源</span><br><span class="hljs-type">static</span> CRelease release;<br>&#125;;<br>Singleton* Singleton::single = <span class="hljs-literal">nullptr</span>;<br>Singleton::CRelease Singleton::release;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Singleton *p1 = Singleton::<span class="hljs-built_in">getInstance</span>();<br>Singleton *p2 = Singleton::<span class="hljs-built_in">getInstance</span>();<br>Singleton *p3 = Singleton::<span class="hljs-built_in">getInstance</span>();<br>cout &lt;&lt; p1 &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; p2 &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; p3 &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样单例对象的实例能自动析构 <br></p><h2 id="多线程情况下的单例模式"><a href="#多线程情况下的单例模式" class="headerlink" title="多线程情况下的单例模式"></a>多线程情况下的单例模式</h2><p>最近在开发服务端程序时经常遇到多线程的情况，单例模式在多线程环境下可能会出现竞争，所以要考虑好各种单例模式的情况。</p><h3 id="饿汉式单例模式-1"><a href="#饿汉式单例模式-1" class="headerlink" title="饿汉式单例模式"></a>饿汉式单例模式</h3><p>在饿汉式的单例模式中，单例对象定义成static静态变量，在main函数运行之前就初始化好了,不存在线程安全问题。 <br></p><h3 id="懒汉式单例模式-1"><a href="#懒汉式单例模式-1" class="headerlink" title="懒汉式单例模式"></a>懒汉式单例模式</h3><p>在上面的懒汉式代码里有</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (single == <span class="hljs-literal">nullptr</span>) &#123;<br><br>single = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Singleton</span>();<br>&#125;<br><span class="hljs-keyword">return</span> single;<br></code></pre></td></tr></table></figure><p>在获取单例对象实例的过程中可能有多个线程同时进入到if语句中，会new出多个对象。<br><br>如果仅靠在函数前加锁来解决上述的问题，每次调用getInstance都需要加锁解锁，而程序中仅第一次调用getInstance函数时需要上锁，后面的上锁解锁操作都没有必要。所以需要在if里面加上互斥锁：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 成员变量中需要加上静态的互斥锁</span><br><span class="hljs-comment">// 类外需要对互斥锁进行初始化</span><br><span class="hljs-function"><span class="hljs-type">static</span> Singleton* <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (single == <span class="hljs-literal">nullptr</span>) &#123;<br><span class="hljs-comment">// 获取互斥锁</span><br><span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mutex);<br><span class="hljs-comment">/* </span><br><span class="hljs-comment">这里需要再添加一个if判断，否则当两个</span><br><span class="hljs-comment">线程都进入这里，又会多次new对象，不符合</span><br><span class="hljs-comment">单例模式</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">if</span>(single == <span class="hljs-literal">nullptr</span>) &#123;<br>single = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Singleton</span>();<br>&#125;<br><span class="hljs-comment">// 释放互斥锁</span><br><span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mutex);<br>&#125;<br><br><span class="hljs-keyword">return</span> single;<br>&#125;<br><span class="hljs-comment">// 这种叫双重校验锁</span><br></code></pre></td></tr></table></figure><br><h4 id="懒汉式的单例模式还有一种线程安全的实现方法叫静态内部类"><a href="#懒汉式的单例模式还有一种线程安全的实现方法叫静态内部类" class="headerlink" title="懒汉式的单例模式还有一种线程安全的实现方法叫静态内部类"></a>懒汉式的单例模式还有一种线程安全的实现方法叫静态内部类</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">static</span> Singleton* <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">static</span> Singleton single; <span class="hljs-comment">// 定义唯一的对象实例</span><br><span class="hljs-keyword">return</span> &amp;single;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">static</span> Singleton *single;<br><span class="hljs-built_in">Singleton</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;Singleton()&quot;</span> &lt;&lt; endl; &#125;<br>~<span class="hljs-built_in">Singleton</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;~Singleton()&quot;</span> &lt;&lt; endl;&#125;<br><span class="hljs-built_in">Singleton</span>(<span class="hljs-type">const</span> Singleton&amp;);<br>&#125;;<br></code></pre></td></tr></table></figure><p>假设线程A第一次调用getInstance，同时线程B也进入到了getInstance函数，会不会对single都进行初始化呢？其实是不会的。<br><br>对于static静态局部变量的初始化，编译器会自动对它的初始化进行加锁和解锁控制，使静态局部变量的初始化成为线程安全的操作，不用担心多个线程都会初始化静态局部变量，因此上面的懒汉单例模式是线程安全的单例模式！<br><br>此外还有一种叫枚举类的单例模式，应该很少用，不做介绍了。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程池</title>
    <link href="/2022/05/07/2022-5-7-c-%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <url>/2022/05/07/2022-5-7-c-%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="c-中的多线程"><a href="#c-中的多线程" class="headerlink" title="c++中的多线程"></a>c++中的多线程</h2><p>c++中一个线程以对象的形式存在，可以用thread来定义线程对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-comment">// 入口函数1</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;hello world&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br><span class="hljs-comment">// 入口函数2</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;   <br>    <span class="hljs-function">thread <span class="hljs-title">t1</span><span class="hljs-params">(func1)</span></span>;<br>    <span class="hljs-function">thread <span class="hljs-title">t2</span><span class="hljs-params">(func2, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;<br>    t1.<span class="hljs-built_in">join</span>();              <span class="hljs-comment">// 等待线程t1结束</span><br>    t2.<span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="开辟多个线程完成同一任务"><a href="#开辟多个线程完成同一任务" class="headerlink" title="开辟多个线程完成同一任务"></a>开辟多个线程完成同一任务</h3><p>开辟10个线程计算5000w以内的素数的个数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-comment">// 功能函数</span><br><span class="hljs-comment">// 试除法</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_prime</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i * i &lt;= x; i++) &#123;<br>        <span class="hljs-keyword">if</span> (x % i == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">prime_count</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l; i &lt;= r; i++) &#123;<br>        ans += <span class="hljs-built_in">is_prime</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-comment">// 多线程入口函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">worker</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> &amp;ret)</span> </span>&#123;<br>    ret = <span class="hljs-built_in">prime_count</span>(l, r);<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;   <br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> batch 5000000</span><br>    thread *t[<span class="hljs-number">10</span>];<br>    <span class="hljs-type">int</span> ret[<span class="hljs-number">10</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">10</span>; i++, j += batch) &#123;<br>        t[i] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">thread</span>(worker, j, j + batch - <span class="hljs-number">1</span>, <span class="hljs-built_in">ref</span>(ret[i]));<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) t[i]-&gt;<span class="hljs-built_in">join</span>();<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) ans += ret[i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : t) <span class="hljs-keyword">delete</span> x;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>如果用线程池来实现上面的任务，需要维护一个任务队列，一个线程池。让每一个thread创建后，就去执行入口函数：循环获取task、执行。下面实现Task类和ThreadPool类。</p><h3 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 绑定函数和参数,代表任务</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Task</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 绑定函数和参数</span><br>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> FUNC_T, <span class="hljs-keyword">typename</span> ...ARGS&gt;</span><br><span class="hljs-function">    <span class="hljs-title">Task</span><span class="hljs-params">(FUNC_T func, ARGS ...args)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;func = <span class="hljs-built_in">bind</span>(func, forward&lt;ARGS&gt;(args)...); <br>    &#125;<br><br>    <span class="hljs-comment">// 执行任务</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">func</span>(); &#125;<br><br><span class="hljs-keyword">private</span>:<br>    function&lt;<span class="hljs-type">void</span>()&gt; func;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="ThreadPool"><a href="#ThreadPool" class="headerlink" title="ThreadPool"></a>ThreadPool</h3><p>实现线程池需要用到锁和条件变量，锁来保证任务的添加和移除（获取）的互斥性；一个条件变量保证多个线程获取task的同步性：当任务队列为空时，线程应该等待（阻塞）。<br></p><h4 id="ThreadPool成员属性："><a href="#ThreadPool成员属性：" class="headerlink" title="ThreadPool成员属性："></a>ThreadPool成员属性：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">bool</span> starting;    <span class="hljs-comment">// 标记线程池是否启动</span><br><br><span class="hljs-type">int</span> thread_size;  <span class="hljs-comment">// 线程池大小</span><br><br>mutex m_mutex;<br><br>condition_variable m_cond;<br><br>vector&lt;thread*&gt; threads;    <span class="hljs-comment">// 存储每个线程</span><br><br>unordered_map&lt;thread::id, <span class="hljs-type">bool</span>&gt; running;    <span class="hljs-comment">// 存储每个线程运行状态</span><br><br>queue&lt;Task*&gt; tasks;         <span class="hljs-comment">// 任务队列</span><br></code></pre></td></tr></table></figure><h4 id="构造ThreadPool"><a href="#构造ThreadPool" class="headerlink" title="构造ThreadPool"></a>构造ThreadPool</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 设置线程数量，并创建线程</span><br><span class="hljs-built_in">ThreadPool</span>(<span class="hljs-type">int</span> n = <span class="hljs-number">1</span>) <br>: <span class="hljs-built_in">thread_size</span>(n), <span class="hljs-built_in">threads</span>(n), <span class="hljs-built_in">starting</span>(<span class="hljs-literal">false</span>) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">start</span>();<br>&#125;<br><br><span class="hljs-comment">// 创建线程</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; thread_size; i++) &#123;<br>        threads[i] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">thread</span>(&amp;ThreadPool::worker, <span class="hljs-keyword">this</span>);<br>    &#125;<br>    starting = <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// worker:1、取任务 2、执行任务</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">worker</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> id = this_thread::<span class="hljs-built_in">get_id</span>();<br>    running[id] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">while</span> (running[id]) &#123;<br>        Task *t = <span class="hljs-built_in">get_task</span>();<br>        t-&gt;<span class="hljs-built_in">run</span>();<br>        <span class="hljs-keyword">delete</span> t;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 从队列取任务，需要加锁操作</span><br><span class="hljs-comment">// 当队列中没有任务时，用条件变量等待</span><br><span class="hljs-function">Task *<span class="hljs-title">get_task</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">unique_lock&lt;mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(m_mutex)</span></span>;<br>    <span class="hljs-keyword">while</span> (tasks.<span class="hljs-built_in">empty</span>()) m_cond.<span class="hljs-built_in">wait</span>(lock);<br>    Task *t = tasks.<span class="hljs-built_in">front</span>();<br>    tasks.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="在线程池中添加任务-添加任务后通知一个正在等待的线程"><a href="#在线程池中添加任务-添加任务后通知一个正在等待的线程" class="headerlink" title="在线程池中添加任务,添加任务后通知一个正在等待的线程"></a>在线程池中添加任务,添加任务后通知一个正在等待的线程</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> FUNC_T, <span class="hljs-keyword">typename</span> ...ARGS&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_task</span><span class="hljs-params">(FUNC_T func, ARGS ...args)</span> </span>&#123;<br>    <span class="hljs-function">unique_lock&lt;mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(m_mutex)</span></span>;<br>    <br>    <span class="hljs-comment">// 将任务绑定到Task并添加到队列中</span><br>    tasks.<span class="hljs-built_in">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Task</span>(func, forward&lt;ARGS&gt;(args)...));<br>    <br>    m_cond.<span class="hljs-built_in">notify_one</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="等待线程结束"><a href="#等待线程结束" class="headerlink" title="等待线程结束"></a>等待线程结束</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-comment">// 外部可调用stop（）来等待线程结束</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (starting == <span class="hljs-literal">false</span>) <span class="hljs-keyword">return</span> ;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; threads.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">add_task</span>(&amp;ThreadPool::stop_running, <span class="hljs-keyword">this</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; threads.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        threads[i]-&gt;<span class="hljs-built_in">join</span>();<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; threads.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-keyword">delete</span> threads[i];<br>        threads[i] = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    starting = <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 当线程添加这个方法后在worker中就会被停止</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">stop_running</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> id = this_thread::<span class="hljs-built_in">get_id</span>();<br>    running[id] = <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 析构</span><br>~<span class="hljs-built_in">ThreadPool</span>() &#123;<br>    <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">stop</span>();<br>    <span class="hljs-keyword">while</span> (!tasks.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">delete</span> tasks.<span class="hljs-built_in">front</span>();<br>        tasks.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="运行线程池"><a href="#运行线程池" class="headerlink" title="运行线程池"></a>运行线程池</h2><p>先定义需要执行的任务函数，这里还是以计算素数个数为例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> batch 5000000</span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_prime</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i * i &lt;= x; i++) &#123;<br>        <span class="hljs-keyword">if</span> (x % i == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">prime_count</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l; i &lt;= r; i++) &#123;<br>        ans += <span class="hljs-built_in">is_prime</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-comment">// 入口函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">worker</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> &amp;ret)</span> </span>&#123;<br>    ret = <span class="hljs-built_in">prime_count</span>(l, r);<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;   <br>    <span class="hljs-comment">// 创建5个线程 </span><br>    <span class="hljs-function">ThreadPool <span class="hljs-title">tp</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;<br>    <span class="hljs-type">int</span> ret[<span class="hljs-number">10</span>];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">10</span>; i++, j += batch) &#123;<br>        tp.<span class="hljs-built_in">add_task</span>(worker, j, j + batch - <span class="hljs-number">1</span>, <span class="hljs-built_in">ref</span>(ret[i]));<br>    &#125;<br><br>    tp.<span class="hljs-built_in">stop</span>();<br><br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : ret) ans += x;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Task</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> FUNC_T, <span class="hljs-keyword">typename</span> ...ARGS&gt;</span><br><span class="hljs-function">    <span class="hljs-title">Task</span><span class="hljs-params">(FUNC_T func, ARGS ...args)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;func = <span class="hljs-built_in">bind</span>(func, forward&lt;ARGS&gt;(args)...); <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">func</span>(); &#125;<br><br><span class="hljs-keyword">private</span>:<br>    function&lt;<span class="hljs-type">void</span>()&gt; func;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPool</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ThreadPool</span>(<span class="hljs-type">int</span> n = <span class="hljs-number">1</span>) : <span class="hljs-built_in">thread_size</span>(n), <span class="hljs-built_in">threads</span>(n), <span class="hljs-built_in">starting</span>(<span class="hljs-literal">false</span>) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">start</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// worker</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">worker</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> id = this_thread::<span class="hljs-built_in">get_id</span>();<br>        running[id] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">while</span> (running[id]) &#123;<br>            Task *t = <span class="hljs-built_in">get_task</span>();<br>            t-&gt;<span class="hljs-built_in">run</span>();<br>            <span class="hljs-keyword">delete</span> t;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// start</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; thread_size; i++) &#123;<br>            threads[i] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">thread</span>(&amp;ThreadPool::worker, <span class="hljs-keyword">this</span>); <br>        &#125;<br>        starting = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// stop</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (starting == <span class="hljs-literal">false</span>) <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; threads.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">add_task</span>(&amp;ThreadPool::stop_running, <span class="hljs-keyword">this</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; threads.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            threads[i]-&gt;<span class="hljs-built_in">join</span>();<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; threads.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">delete</span> threads[i];<br>            threads[i] = <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        starting = <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> FUNC_T, <span class="hljs-keyword">typename</span> ...ARGS&gt;</span><br><span class="hljs-function">    <span class="hljs-type">void</span> <span class="hljs-title">add_task</span><span class="hljs-params">(FUNC_T func, ARGS ...args)</span> </span>&#123;<br>        <span class="hljs-function">unique_lock&lt;mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(m_mutex)</span></span>;<br>        tasks.<span class="hljs-built_in">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Task</span>(func, forward&lt;ARGS&gt;(args)...));<br>        m_cond.<span class="hljs-built_in">notify_one</span>();<br>    &#125;<br><br>    ~<span class="hljs-built_in">ThreadPool</span>() &#123;<br>        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">stop</span>();<br>        <span class="hljs-keyword">while</span> (!tasks.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">delete</span> tasks.<span class="hljs-built_in">front</span>();<br>            tasks.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">stop_running</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> id = this_thread::<span class="hljs-built_in">get_id</span>();<br>        running[id] = <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-function">Task *<span class="hljs-title">get_task</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-function">unique_lock&lt;mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(m_mutex)</span></span>;<br>        <span class="hljs-keyword">while</span> (tasks.<span class="hljs-built_in">empty</span>()) m_cond.<span class="hljs-built_in">wait</span>(lock);<br>        Task *t = tasks.<span class="hljs-built_in">front</span>();<br>        tasks.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br><br>    <span class="hljs-type">bool</span> starting;<br><br>    <span class="hljs-type">int</span> thread_size;<br><br>    mutex m_mutex;<br><br>    condition_variable m_cond;<br><br>    vector&lt;thread*&gt; threads;<br><br>    unordered_map&lt;thread::id, <span class="hljs-type">bool</span>&gt; running;<br><br>    queue&lt;Task*&gt; tasks;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>std::function</title>
    <link href="/2022/05/06/2022-5-6-c-function/"/>
    <url>/2022/05/06/2022-5-6-c-function/</url>
    
    <content type="html"><![CDATA[<h2 id="function"><a href="#function" class="headerlink" title="function"></a>function</h2><h4 id="std-function-的实例能存储、复制及调用任何可调用-Callable-目标——函数、-lambda-表达式、-bind-表达式或其他函数对象，还有指向成员函数指针和指向数据成员指针。"><a href="#std-function-的实例能存储、复制及调用任何可调用-Callable-目标——函数、-lambda-表达式、-bind-表达式或其他函数对象，还有指向成员函数指针和指向数据成员指针。" class="headerlink" title="std::function 的实例能存储、复制及调用任何可调用 (Callable) 目标——函数、 lambda 表达式、 bind 表达式或其他函数对象，还有指向成员函数指针和指向数据成员指针。"></a>std::function 的实例能存储、复制及调用任何可调用 (Callable) 目标——函数、 lambda 表达式、 bind 表达式或其他函数对象，还有指向成员函数指针和指向数据成员指针。<br></h4><p>使用function：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add1</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123; <span class="hljs-keyword">return</span> a + b; &#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">add2</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">add2</span>(<span class="hljs-type">int</span> x = <span class="hljs-number">2</span>) : <span class="hljs-built_in">x</span>(x) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> (a + b) * <span class="hljs-number">2</span>;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> x;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;   <br>    add2 a1;<br>    function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; f1 = a1;<br>    function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; f2 = add1;<br>    function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; f3 = [](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)-&gt;<span class="hljs-type">int</span>&#123;<br>                                    <span class="hljs-keyword">return</span> a + b;<br>                                    &#125;;<br>    cout &lt;&lt; <span class="hljs-built_in">f1</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) &lt;&lt; endl;       <span class="hljs-comment">// 3</span><br>    cout &lt;&lt; <span class="hljs-built_in">f2</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) &lt;&lt; endl;       <span class="hljs-comment">// 6</span><br>    cout &lt;&lt; <span class="hljs-built_in">f3</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) &lt;&lt; endl;       <span class="hljs-comment">// 3</span><br>    f2 = f1;<br>    cout &lt;&lt; <span class="hljs-built_in">f2</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>) &lt;&lt; endl;       <span class="hljs-comment">// 7</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="myfunction"><a href="#myfunction" class="headerlink" title="myfunction"></a>myfunction</h2><h4 id="实现function模板类需要实现以上的功能："><a href="#实现function模板类需要实现以上的功能：" class="headerlink" title="实现function模板类需要实现以上的功能："></a>实现function模板类需要实现以上的功能：<br></h4><h4 id="1、能用形如function-lt-int-int-int-gt-进行声明使用，在定义模板类的时候传入类型的形式应该相同，所以应该采用模板类的偏特化版本以符合使用方式。"><a href="#1、能用形如function-lt-int-int-int-gt-进行声明使用，在定义模板类的时候传入类型的形式应该相同，所以应该采用模板类的偏特化版本以符合使用方式。" class="headerlink" title="1、能用形如function&lt;int(int, int)&gt;进行声明使用，在定义模板类的时候传入类型的形式应该相同，所以应该采用模板类的偏特化版本以符合使用方式。"></a>1、能用形如function&lt;int(int, int)&gt;进行声明使用，在定义模板类的时候传入类型的形式应该相同，所以应该采用模板类的偏特化版本以符合使用方式。</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> ... ARGS&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myfunction</span>;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> ... ARGS&gt; <span class="hljs-comment">// 符合使用方式采用偏特化版本</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myfunction</span>&lt;<span class="hljs-built_in">T</span>(ARGS...)&gt; &#123;&#125;;<br></code></pre></td></tr></table></figure><h4 id="2、function能够存储普通的函数（包括lamda表达式）和函数对象，所以myfunction应该对这两种传入情况分别有两个构造函数。"><a href="#2、function能够存储普通的函数（包括lamda表达式）和函数对象，所以myfunction应该对这两种传入情况分别有两个构造函数。" class="headerlink" title="2、function能够存储普通的函数（包括lamda表达式）和函数对象，所以myfunction应该对这两种传入情况分别有两个构造函数。"></a>2、function能够存储普通的函数（包括lamda表达式）和函数对象，所以myfunction应该对这两种传入情况分别有两个构造函数。<br></h4><h4 id="3、同时定义一个类型来存储这两种传入的参数（在这里定义一个基类，普通函数指针和函数对象分别继承自基类）。"><a href="#3、同时定义一个类型来存储这两种传入的参数（在这里定义一个基类，普通函数指针和函数对象分别继承自基类）。" class="headerlink" title="3、同时定义一个类型来存储这两种传入的参数（在这里定义一个基类，普通函数指针和函数对象分别继承自基类）。"></a>3、同时定义一个类型来存储这两种传入的参数（在这里定义一个基类，普通函数指针和函数对象分别继承自基类）。</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> ... ARGS&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;&#125;;<br><br><span class="hljs-comment">// base类的派生类用来存储函数指针</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> ... ARGS&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">normal_function</span> : <span class="hljs-keyword">public</span> Base&lt;T, ARGS...&gt; &#123;&#125;;<br><br><span class="hljs-comment">// 存储可调用对象,由于传入对象的类型不可知，加多一个CLASS_T用于模板构造</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> CLASS_T, <span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> ... ARGS&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">functor</span> : <span class="hljs-keyword">public</span> Base&lt;T, ARGS...&gt; &#123;&#125;;<br><br><br><span class="hljs-comment">// function</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> ... ARGS&gt; <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myfunction</span>&lt;<span class="hljs-built_in">T</span>(ARGS...)&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 用于可调用函数的构造函数</span><br>    <span class="hljs-built_in">myfunction</span>(<span class="hljs-built_in">T</span> (*ptr)(ARGS...)) <br>    : <span class="hljs-built_in">ptr</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">normal_function</span>&lt;T, ARGS...&gt;(ptr)) &#123;&#125;<br><br>    <span class="hljs-comment">// 用于对象的构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> CLASS_T&gt;</span><br><span class="hljs-function">    <span class="hljs-title">myfunction</span><span class="hljs-params">(CLASS_T obj)</span> </span><br><span class="hljs-function">    : ptr(new functor&lt;CLASS_T, T, ARGS...&gt;(obj)) &#123;</span>&#125;<br><br><span class="hljs-keyword">private</span>:<br>    Base&lt;T, ARGS...&gt; *ptr;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="4、重载（）：上面function的使用是用“f1-1-2-”来调用函数的，所以应该重载（）运算符来用于函数调用。"><a href="#4、重载（）：上面function的使用是用“f1-1-2-”来调用函数的，所以应该重载（）运算符来用于函数调用。" class="headerlink" title="4、重载（）：上面function的使用是用“f1(1, 2)”来调用函数的，所以应该重载（）运算符来用于函数调用。"></a>4、重载（）：上面function的使用是用“f1(1, 2)”来调用函数的，所以应该重载（）运算符来用于函数调用。<br></h4><h4 id="5、重载-：用于myfunction类之间的赋值"><a href="#5、重载-：用于myfunction类之间的赋值" class="headerlink" title="5、重载=：用于myfunction类之间的赋值"></a>5、重载=：用于myfunction类之间的赋值</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 重载（）运算符</span><br><span class="hljs-function">T <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(ARGS ...args)</span> </span>&#123;<br>    <span class="hljs-comment">// 这里不能return func(args...);</span><br>    <span class="hljs-comment">// 此时要传入的可能是右值或者左值，所以不能直接传，会使所有的右值变成左值</span><br>    <span class="hljs-keyword">return</span> ptr-&gt;<span class="hljs-built_in">run</span>(forward&lt;ARGS&gt;(args)...);<br>&#125;<br><br><span class="hljs-comment">// 重载赋值运算符</span><br>myfunction &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> myfunction&lt;<span class="hljs-built_in">T</span>(ARGS...)&gt; &amp;mfun) &#123;<br>    <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>-&gt;ptr; <span class="hljs-comment">// 把当前函数指针对象的信息消除</span><br>    <span class="hljs-comment">//this-&gt;ptr = mfun.ptr; 不能浅拷贝。base类型只是虚拟类，所以要获取实际对象的拷贝</span><br>    <span class="hljs-keyword">this</span>-&gt;ptr = mfun.ptr-&gt;<span class="hljs-built_in">getCopy</span>();<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6、ptr-gt-run：在base类定义虚函数，子类实现。"><a href="#6、ptr-gt-run：在base类定义虚函数，子类实现。" class="headerlink" title="6、ptr-&gt;run：在base类定义虚函数，子类实现。"></a>6、ptr-&gt;run：在base类定义虚函数，子类实现。<br></h4><h4 id="7、ptr-gt-getCopy-获取myfunction类的实际对象的拷贝。"><a href="#7、ptr-gt-getCopy-获取myfunction类的实际对象的拷贝。" class="headerlink" title="7、ptr-&gt;getCopy():获取myfunction类的实际对象的拷贝。"></a>7、ptr-&gt;getCopy():获取myfunction类的实际对象的拷贝。</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 基类</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> ... ARGS&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> T <span class="hljs-title">run</span><span class="hljs-params">(ARGS...)</span> </span>= <span class="hljs-number">0</span>; <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> Base&lt;T, ARGS...&gt; *<span class="hljs-title">getCopy</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base</span>() &#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">// 函数指针子类</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> ... ARGS&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">normal_function</span> : <span class="hljs-keyword">public</span> Base&lt;T, ARGS...&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">normal_function</span>(<span class="hljs-built_in">T</span> (*ptr)(ARGS...)) : <span class="hljs-built_in">func</span>(ptr) &#123;&#125;<br><br>    <span class="hljs-function">T <span class="hljs-title">run</span><span class="hljs-params">(ARGS ...args)</span> <span class="hljs-keyword">override</span></span>&#123;  <span class="hljs-comment">// 注意此时要传入的可能是右值或者左值，所以不能直接传，会使所有的右值变成左值</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">func</span>(forward&lt;ARGS&gt;(args)...); <span class="hljs-comment">// 不可以return func(args...);</span><br>    &#125;<br><br>    <span class="hljs-function">Base&lt;T, ARGS...&gt; *<span class="hljs-title">getCopy</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">normal_function</span>(*<span class="hljs-keyword">this</span>);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">T</span> (*func)(ARGS...);<br>&#125;;<br><br><span class="hljs-comment">// 存储可调用对象子类</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> CLASS_T, <span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> ... ARGS&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">functor</span> : <span class="hljs-keyword">public</span> Base&lt;T, ARGS...&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">functor</span>(CLASS_T obj) : <span class="hljs-built_in">obj</span>(obj) &#123;&#125;<br><br>    <span class="hljs-function">T <span class="hljs-title">run</span><span class="hljs-params">(ARGS ...args)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">obj</span>(forward&lt;ARGS&gt;(args)...);<br>    &#125;<br><br>    <span class="hljs-function">Base&lt;T, ARGS...&gt; *<span class="hljs-title">getCopy</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">functor</span>(*<span class="hljs-keyword">this</span>);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    CLASS_T obj;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> ... ARGS&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> T <span class="hljs-title">run</span><span class="hljs-params">(ARGS...)</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">// 纯虚函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> Base&lt;T, ARGS...&gt; *<span class="hljs-title">getCopy</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base</span>() &#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">// base类的派生类用来存储函数指针</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> ... ARGS&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">normal_function</span> : <span class="hljs-keyword">public</span> Base&lt;T, ARGS...&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">normal_function</span>(<span class="hljs-built_in">T</span> (*ptr)(ARGS...)) : <span class="hljs-built_in">func</span>(ptr) &#123;&#125;<br><br>    <span class="hljs-function">T <span class="hljs-title">run</span><span class="hljs-params">(ARGS ...args)</span> <span class="hljs-keyword">override</span></span>&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">func</span>(forward&lt;ARGS&gt;(args)...); <br>    &#125;<br><br>    <span class="hljs-function">Base&lt;T, ARGS...&gt; *<span class="hljs-title">getCopy</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">normal_function</span>(*<span class="hljs-keyword">this</span>);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">T</span> (*func)(ARGS...);<br>&#125;;<br><br><span class="hljs-comment">// 存储可调用对象</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> CLASS_T, <span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> ... ARGS&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">functor</span> : <span class="hljs-keyword">public</span> Base&lt;T, ARGS...&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">functor</span>(CLASS_T obj) : <span class="hljs-built_in">obj</span>(obj) &#123;&#125;<br><br>    <span class="hljs-function">T <span class="hljs-title">run</span><span class="hljs-params">(ARGS ...args)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">obj</span>(forward&lt;ARGS&gt;(args)...);<br>    &#125;<br><br>    <span class="hljs-function">Base&lt;T, ARGS...&gt; *<span class="hljs-title">getCopy</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">functor</span>(*<span class="hljs-keyword">this</span>);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    CLASS_T obj;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> ... ARGS&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myfunction</span>;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> ... ARGS&gt; <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myfunction</span>&lt;<span class="hljs-built_in">T</span>(ARGS...)&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-built_in">myfunction</span>(<span class="hljs-built_in">T</span> (*ptr)(ARGS...)) : <span class="hljs-built_in">ptr</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">normal_function</span>&lt;T, ARGS...&gt;(ptr)) &#123;&#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> CLASS_T&gt;</span><br><span class="hljs-function">    <span class="hljs-title">myfunction</span><span class="hljs-params">(CLASS_T obj)</span> : ptr(new functor&lt;CLASS_T, T, ARGS...&gt;(obj)) &#123;</span>&#125;<br><br>    <span class="hljs-comment">// 重载（）运算符</span><br>    <span class="hljs-function">T <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(ARGS ...args)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> ptr-&gt;<span class="hljs-built_in">run</span>(forward&lt;ARGS&gt;(args)...);<br>    &#125;<br><br>    <span class="hljs-comment">// 重载赋值运算符</span><br>    myfunction &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> myfunction&lt;<span class="hljs-built_in">T</span>(ARGS...)&gt; &amp;mfun) &#123;<br>        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>-&gt;ptr; <br>        <span class="hljs-keyword">this</span>-&gt;ptr = mfun.ptr-&gt;<span class="hljs-built_in">getCopy</span>();<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// myfunction析构</span><br>    ~<span class="hljs-built_in">myfunction</span>() &#123;<br>        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>-&gt;ptr;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    Base&lt;T, ARGS...&gt; *ptr;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="测试："><a href="#测试：" class="headerlink" title="测试："></a>测试：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;   <br>    add2 a1;<br>    myfunction&lt;<span class="hljs-built_in">int</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; f1 = a1;<br>    myfunction&lt;<span class="hljs-built_in">int</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; f2 = add1;<br>    myfunction&lt;<span class="hljs-built_in">int</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; f3 = [](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)-&gt;<span class="hljs-type">int</span>&#123;<br>                                    <span class="hljs-keyword">return</span> a + b;<br>                                    &#125;;<br>    cout &lt;&lt; <span class="hljs-built_in">f1</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) &lt;&lt; endl;       <span class="hljs-comment">// 3</span><br>    cout &lt;&lt; <span class="hljs-built_in">f2</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) &lt;&lt; endl;       <span class="hljs-comment">// 6</span><br>    cout &lt;&lt; <span class="hljs-built_in">f3</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) &lt;&lt; endl;       <span class="hljs-comment">// 3</span><br>    f2 = f1;<br>    cout &lt;&lt; <span class="hljs-built_in">f2</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>) &lt;&lt; endl;       <span class="hljs-comment">// 7</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++哈希表</title>
    <link href="/2022/05/04/2022-5-4-c-%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    <url>/2022/05/04/2022-5-4-c-%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h4 id="哈希表（Hash-Table）是根据关键码的值直接访问数据的数据结构，我们经常用的数组就是一张哈希表，哈希表中的关键码就是数组的索引下标，通过下标直接访问数组中的元素。"><a href="#哈希表（Hash-Table）是根据关键码的值直接访问数据的数据结构，我们经常用的数组就是一张哈希表，哈希表中的关键码就是数组的索引下标，通过下标直接访问数组中的元素。" class="headerlink" title="哈希表（Hash Table）是根据关键码的值直接访问数据的数据结构，我们经常用的数组就是一张哈希表，哈希表中的关键码就是数组的索引下标，通过下标直接访问数组中的元素。"></a>哈希表（Hash Table）是根据关键码的值直接访问数据的数据结构，我们经常用的数组就是一张哈希表，哈希表中的关键码就是数组的索引下标，通过下标直接访问数组中的元素。<br></h4><h4 id="哈希表一般用来快速判断一个元素是否出现在集合中，查询效率和增删效率都是O-1-。通过哈希函数能实现Key和Value的映射。当实现哈希碰撞时，可以采用拉链法和线性探测法，这里用拉链发解决哈希碰撞，实现unordered-map。"><a href="#哈希表一般用来快速判断一个元素是否出现在集合中，查询效率和增删效率都是O-1-。通过哈希函数能实现Key和Value的映射。当实现哈希碰撞时，可以采用拉链法和线性探测法，这里用拉链发解决哈希碰撞，实现unordered-map。" class="headerlink" title="哈希表一般用来快速判断一个元素是否出现在集合中，查询效率和增删效率都是O(1)。通过哈希函数能实现Key和Value的映射。当实现哈希碰撞时，可以采用拉链法和线性探测法，这里用拉链发解决哈希碰撞，实现unordered_map。"></a>哈希表一般用来快速判断一个元素是否出现在集合中，查询效率和增删效率都是O(1)。通过哈希函数能实现Key和Value的映射。当实现哈希碰撞时，可以采用拉链法和线性探测法，这里用拉链发解决哈希碰撞，实现unordered_map。</h4><h2 id="hashtable的使用"><a href="#hashtable的使用" class="headerlink" title="hashtable的使用"></a>hashtable的使用</h2><p>这里用unordered_map来举例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    unordered_map&lt;<span class="hljs-type">int</span>, string&gt; map;<br>    map.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, string&gt;(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;3423&quot;</span>));<br>    cout &lt;&lt; map[<span class="hljs-number">1</span>] &lt;&lt;endl; <span class="hljs-comment">// 输出3423</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到需要unordered_map定义数据结构存储key和value。由于使用拉链法处理哈希碰撞，应该定义一个Node节点用来存key和value，同时在Node节点中存储指向下一个节点的next指针。<br></p><h2 id="hashtable的Node节点实现"><a href="#hashtable的Node节点实现" class="headerlink" title="hashtable的Node节点实现"></a>hashtable的Node节点实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br><span class="hljs-keyword">public</span> :<br>    <span class="hljs-built_in">Node</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-built_in">Node</span> (string, <span class="hljs-type">int</span>, Node *);<br>    <span class="hljs-function">string <span class="hljs-title">key</span><span class="hljs-params">()</span></span>;               <span class="hljs-comment">// 返回键</span><br>    <span class="hljs-type">int</span> value;                  <span class="hljs-comment">// 值</span><br>    <span class="hljs-function">Node* <span class="hljs-title">next</span><span class="hljs-params">()</span></span>;               <span class="hljs-comment">// 返回当前节点的下一节点</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_next</span><span class="hljs-params">(Node *)</span></span>;      <span class="hljs-comment">// 设置当前节点的下一节点</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(Node *)</span></span>;        <span class="hljs-comment">// 传入一个节点并插入到当前节点后</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">erase_next</span><span class="hljs-params">()</span></span>;          <span class="hljs-comment">// 删除当前节点的下一节点</span><br><br><span class="hljs-keyword">private</span>:<br>    string __key;<br>    Node *__next;<br>&#125;;<br></code></pre></td></tr></table></figure><p>实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">Node::<span class="hljs-built_in">Node</span> (string key, <span class="hljs-type">int</span> value, Node *next = <span class="hljs-literal">nullptr</span>) <br>: __key(key), <span class="hljs-built_in">value</span>(value), __next(next) &#123;&#125;<br><br><span class="hljs-function">string <span class="hljs-title">Node::key</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> __key; &#125;<br><span class="hljs-function">Node* <span class="hljs-title">Node::next</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> __next; &#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 设置当前节点下一个节点的地址</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Node::set_next</span><span class="hljs-params">(Node *next)</span> </span>&#123;<br>    __next = next;<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br><br><span class="hljs-comment">// 传入一个节点并插入到当前节点的后面</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Node::insert</span><span class="hljs-params">(Node *node)</span> </span>&#123;<br>    node-&gt;<span class="hljs-built_in">set_next</span>(<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">next</span>()); <span class="hljs-comment">// 把当前节点的next设置给传入节点的next</span><br>    <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">set_next</span>(node);         <span class="hljs-comment">// 让当前节点指向node节点</span><br>&#125;<br><br><span class="hljs-comment">// 删除下一节点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Node::erase_next</span><span class="hljs-params">()</span> </span>&#123;<br>    Node *p = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">next</span>();<br>    <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> ;<br>    <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">set_next</span>(<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">next</span>()-&gt;<span class="hljs-built_in">next</span>());<br>    <span class="hljs-keyword">delete</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="hashtable的实现"><a href="#hashtable的实现" class="headerlink" title="hashtable的实现"></a>hashtable的实现</h2><p>定义一个数组用来存储Node节点，同时声明数组的大小__size,存储元素的数量data_cnt。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">HashTable</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 哈希函数，传入string通过哈希函数返回数组上的索引</span><br>    <span class="hljs-keyword">using</span> HASH_FUNC_T = function&lt;<span class="hljs-built_in">int</span>(string)&gt;;<br>    <span class="hljs-built_in">HashTable</span>(HASH_FUNC_T hash_func, <span class="hljs-type">int</span> size);<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">insert</span><span class="hljs-params">(string, <span class="hljs-type">int</span>)</span></span>;             <span class="hljs-comment">// 插入一个键值对</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">earse</span><span class="hljs-params">(string)</span></span>;                   <span class="hljs-comment">// 删除一个键值对</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">find</span><span class="hljs-params">(string)</span></span>;                    <span class="hljs-comment">// 查找元素</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">capacity</span><span class="hljs-params">()</span></span>;                       <span class="hljs-comment">// 返回存储元素数量</span><br>    <span class="hljs-type">int</span> &amp;<span class="hljs-keyword">operator</span>[](string);              <span class="hljs-comment">// 重载[]使其能直接通过map[key]访问值</span><br>    <span class="hljs-type">void</span> __swap(HashTable &amp;);             <span class="hljs-comment">// 自定义交换函数，用于扩容</span><br><br>    ~<span class="hljs-built_in">HashTable</span>();<br><br><span class="hljs-keyword">private</span>:<br>    Node *__insert(string, <span class="hljs-type">int</span>);<br>    Node *__find(string);<br>    <span class="hljs-type">void</span> __expand();                      <span class="hljs-comment">// 扩容</span><br>    <span class="hljs-type">int</span> __size, data_cnt;<br>    vector&lt;Node&gt; data;<br>    HASH_FUNC_T hash_func;<br>&#125;;<br></code></pre></td></tr></table></figure><p>实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++">HashTable::<span class="hljs-built_in">HashTable</span>(HASH_FUNC_T hash_func, <span class="hljs-type">int</span> size = <span class="hljs-number">10</span>) <br>: <span class="hljs-built_in">hash_func</span>(hash_func), <span class="hljs-built_in">data</span>(size), __size(size), <span class="hljs-built_in">data_cnt</span>(<span class="hljs-number">0</span>) &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">HashTable::capacity</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> data_cnt; &#125;<br><br><span class="hljs-comment">// 扩容，参考STL的扩容操作</span><br><span class="hljs-type">void</span> HashTable::__expand() &#123;<br>    <span class="hljs-function">HashTable <span class="hljs-title">h</span><span class="hljs-params">(hash_func, <span class="hljs-number">2</span> * __size)</span></span>;   <span class="hljs-comment">// 开辟两倍的空间</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; __size; i++) &#123;    <span class="hljs-comment">// 将原来的所有元素放到新开辟的hashtable中</span><br>        Node *p = data[i].<span class="hljs-built_in">next</span>();<br>        <span class="hljs-keyword">while</span> (p) &#123;<br>            h.<span class="hljs-built_in">insert</span>(p-&gt;<span class="hljs-built_in">key</span>(), p-&gt;value); <span class="hljs-comment">// 将每条链上的节点也放进去</span><br>            p = p-&gt;<span class="hljs-built_in">next</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">this</span>-&gt;__swap(h);  <span class="hljs-comment">// 交换所有数据</span><br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br><br><span class="hljs-type">void</span> HashTable::__swap(HashTable &amp;h) &#123;<br>    <span class="hljs-built_in">swap</span>(__size, h.__size);<br>    <span class="hljs-built_in">swap</span>(data_cnt, h.data_cnt);<br>    <span class="hljs-built_in">swap</span>(data, h.data);<br>    <span class="hljs-built_in">swap</span>(hash_func, h.hash_func);<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br></code></pre></td></tr></table></figure><p>插入节点：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">HashTable::insert</span><span class="hljs-params">(string key, <span class="hljs-type">int</span> value = <span class="hljs-number">0</span>)</span> </span>&#123;<br>    Node *p = __insert(key, value);<br>    <span class="hljs-keyword">if</span> (data_cnt &gt; __size * <span class="hljs-number">2</span>) __expand();    <span class="hljs-comment">// 扩容</span><br>    <span class="hljs-keyword">return</span> p != <span class="hljs-literal">nullptr</span>;<br>&#125;<br><br>Node *HashTable::__insert(string key, <span class="hljs-type">int</span> value) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">find</span>(key)) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;            <span class="hljs-comment">// 如果键已经存在，没必要插入</span><br>    <span class="hljs-type">int</span> ind = <span class="hljs-built_in">hash_func</span>(key) % data.<span class="hljs-built_in">size</span>();   <span class="hljs-comment">// 当前key值在数组中存储的位置</span><br>    Node *p;<br>    data[ind].<span class="hljs-built_in">insert</span>((p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(key, value)));<br>    data_cnt += <span class="hljs-number">1</span>;                            <span class="hljs-comment">// 存储数量增加</span><br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><p>查找元素：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">HashTable::find</span><span class="hljs-params">(string key)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> __find(key) != <span class="hljs-literal">nullptr</span>;<br>&#125;<br><br>Node *HashTable::__find(string key) &#123;<br>    <span class="hljs-type">int</span> ind = <span class="hljs-built_in">hash_func</span>(key) % __size;         <span class="hljs-comment">// 计算出在数组中的位置</span><br>    Node *p = data[ind].<span class="hljs-built_in">next</span>();                <span class="hljs-comment">// 遍历链表中的每个节点</span><br>    <span class="hljs-keyword">while</span> (p &amp;&amp; p-&gt;<span class="hljs-built_in">key</span>() != key) p = p-&gt;<span class="hljs-built_in">next</span>();<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><p>删除节点：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">HashTable::earse</span><span class="hljs-params">(string key)</span> </span>&#123;<br>    <span class="hljs-type">int</span> ind = <span class="hljs-built_in">hash_func</span>(key) % __size;<br>    Node *p = &amp;data[ind];<br>    <span class="hljs-keyword">while</span> (p-&gt;<span class="hljs-built_in">next</span>() &amp;&amp; p-&gt;<span class="hljs-built_in">next</span>()-&gt;<span class="hljs-built_in">key</span>() != key) p = p-&gt;<span class="hljs-built_in">next</span>();<br>    <span class="hljs-keyword">if</span> (p-&gt;<span class="hljs-built_in">next</span>() == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    p-&gt;<span class="hljs-built_in">erase_next</span>();<br>    data_cnt -= <span class="hljs-number">1</span>;   <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>重载[]：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> &amp;HashTable::<span class="hljs-keyword">operator</span>[](string key) &#123;<br>    Node *p = __find(key);<br>    <span class="hljs-keyword">if</span> (p) <span class="hljs-keyword">return</span> p-&gt;value;                   <span class="hljs-comment">// 如果没找到就新插入一个节点</span><br>    <span class="hljs-built_in">insert</span>(key, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> __find(key)-&gt;value;<br>&#125;<br></code></pre></td></tr></table></figure><p>析构：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">HashTable::~<span class="hljs-built_in">HashTable</span>() &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; __size; i++) &#123;<br>        <span class="hljs-keyword">while</span> (data[i].<span class="hljs-built_in">next</span>()) data[i].<span class="hljs-built_in">erase_next</span>(); <span class="hljs-comment">// 删除拉链上的所有节点</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="至此实现完了一个key为string，value为int类型的hashtable，包含insert、find等方法。使用如下："><a href="#至此实现完了一个key为string，value为int类型的hashtable，包含insert、find等方法。使用如下：" class="headerlink" title="至此实现完了一个key为string，value为int类型的hashtable，包含insert、find等方法。使用如下："></a>至此实现完了一个key为string，value为int类型的hashtable，包含insert、find等方法。使用如下：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 先定义一个哈希函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">FUNCC</span><span class="hljs-params">(string key)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">atoi</span>(key.<span class="hljs-built_in">c_str</span>()) % <span class="hljs-number">7</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;   <br>    <span class="hljs-function">HashTable <span class="hljs-title">h1</span><span class="hljs-params">(FUNCC)</span></span>;<br>    cout &lt;&lt; h1.<span class="hljs-built_in">capacity</span>() &lt;&lt; endl;<br>    h1[<span class="hljs-string">&quot;hello&quot;</span>] = <span class="hljs-number">123</span>;<br>    h1[<span class="hljs-string">&quot;world&quot;</span>] = <span class="hljs-number">456</span>;<br>    cout &lt;&lt; h1.<span class="hljs-built_in">capacity</span>() &lt;&lt; endl;<br>    cout &lt;&lt; h1[<span class="hljs-string">&quot;hello&quot;</span>] &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; h1[<span class="hljs-string">&quot;world&quot;</span>] &lt;&lt; endl;<br>    h1.<span class="hljs-built_in">insert</span>(<span class="hljs-string">&quot;aaa&quot;</span>, <span class="hljs-number">1</span>);<br>    cout &lt;&lt; h1[<span class="hljs-string">&quot;aaa&quot;</span>] &lt;&lt; endl;<br>    cout &lt;&lt; h1[<span class="hljs-string">&quot;ccc&quot;</span>] &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">      输出：</span><br><span class="hljs-comment">      0</span><br><span class="hljs-comment">      2</span><br><span class="hljs-comment">      123 456</span><br><span class="hljs-comment">      1</span><br><span class="hljs-comment">      0</span><br><span class="hljs-comment">    */</span><br>&#125;<br></code></pre></td></tr></table></figure><br>## 加入模板完整代码如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br> <br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">FUNCC</span><span class="hljs-params">(string key)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">atoi</span>(key.<span class="hljs-built_in">c_str</span>()) % <span class="hljs-number">7</span>;<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> KEY, <span class="hljs-keyword">typename</span> VALUE&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Node</span>() = <span class="hljs-keyword">default</span>;<br>    VALUE value;<br><br>    <span class="hljs-built_in">Node</span> (KEY key, VALUE value, Node&lt;KEY, VALUE&gt; *next = <span class="hljs-literal">nullptr</span>)<br>    : __key(key), <span class="hljs-built_in">value</span>(value), __next(next) &#123;&#125;<br><br>    <span class="hljs-function">KEY <span class="hljs-title">key</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> __key; &#125;               <br>    <br>    <span class="hljs-function">Node&lt;KEY, VALUE&gt;* <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> __next; &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_next</span><span class="hljs-params">(Node&lt;KEY, VALUE&gt; *next)</span> </span>&#123;  <br>        __next = next;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(Node&lt;KEY, VALUE&gt; *node)</span> </span>&#123;  <br>        node-&gt;<span class="hljs-built_in">set_next</span>(<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">next</span>());<br>        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">set_next</span>(node);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">erase_next</span><span class="hljs-params">()</span> </span>&#123; <br>        Node&lt;KEY, VALUE&gt; *p = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">next</span>();<br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">set_next</span>(<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">next</span>()-&gt;<span class="hljs-built_in">next</span>());<br>        <span class="hljs-keyword">delete</span> p;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    KEY __key;<br>    Node&lt;KEY, VALUE&gt; *__next;<br>&#125;;<br><span class="hljs-comment">/////////////////////</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> KEY, <span class="hljs-keyword">typename</span> VALUE&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HashTable</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> HASH_FUNC_T = function&lt;<span class="hljs-built_in">int</span>(string)&gt;;<br>    <span class="hljs-built_in">HashTable</span>(HASH_FUNC_T hash_func, <span class="hljs-type">int</span> size = <span class="hljs-number">10</span>)<br>    : <span class="hljs-built_in">hash_func</span>(hash_func), <span class="hljs-built_in">data</span>(size), __size(size), <span class="hljs-built_in">data_cnt</span>(<span class="hljs-number">0</span>) &#123;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">insert</span><span class="hljs-params">(KEY key, VALUE value = VALUE())</span> </span>&#123;  <br>        Node&lt;KEY, VALUE&gt; *p = __insert(key, value);<br>        <span class="hljs-keyword">if</span> (data_cnt &gt; __size * <span class="hljs-number">2</span>) __expand();<br>        <span class="hljs-keyword">return</span> p != <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">earse</span><span class="hljs-params">(KEY key)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ind = <span class="hljs-built_in">hash_func</span>(key) % data.<span class="hljs-built_in">size</span>();<br>        Node&lt;KEY, VALUE&gt; *p = &amp;data[ind];<br>        <span class="hljs-keyword">while</span> (p-&gt;<span class="hljs-built_in">next</span>() &amp;&amp; p-&gt;<span class="hljs-built_in">next</span>()-&gt;<span class="hljs-built_in">key</span>() != key) p = p-&gt;<span class="hljs-built_in">next</span>();<br>        <span class="hljs-comment">// 找没找到</span><br>        <span class="hljs-keyword">if</span> (p-&gt;<span class="hljs-built_in">next</span>() == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        p-&gt;<span class="hljs-built_in">erase_next</span>();<br>        data_cnt -= <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">find</span><span class="hljs-params">(KEY key)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> __find(key) != <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">capacity</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> data_cnt; &#125;<br><br>    VALUE &amp;<span class="hljs-keyword">operator</span>[](KEY key) &#123; <br>        Node&lt;KEY, VALUE&gt; *p = __find(key);<br>        <span class="hljs-keyword">if</span> (p) <span class="hljs-keyword">return</span> p-&gt;value;<br>        <span class="hljs-built_in">insert</span>(key, <span class="hljs-built_in">VALUE</span>());<br>        <span class="hljs-keyword">return</span> __find(key)-&gt;value;<br>    &#125;<br><br>    <span class="hljs-type">void</span> __swap(HashTable&lt;KEY, VALUE&gt; &amp;h) &#123;<br>        <span class="hljs-built_in">swap</span>(__size, h.__size);<br>        <span class="hljs-built_in">swap</span>(data_cnt, h.data_cnt);<br>        <span class="hljs-built_in">swap</span>(data, h.data);<br>        <span class="hljs-built_in">swap</span>(hash_func, h.hash_func);<br>    &#125;<br><br>    ~<span class="hljs-built_in">HashTable</span>() &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; __size; i++) &#123;<br>            <span class="hljs-keyword">while</span> (data[i].<span class="hljs-built_in">next</span>()) data[i].<span class="hljs-built_in">erase_next</span>(); <br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    Node&lt;KEY, VALUE&gt; *__insert(KEY key, VALUE value) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">find</span>(key)) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>; <br>        <span class="hljs-type">int</span> ind = <span class="hljs-built_in">hash_func</span>(key) % data.<span class="hljs-built_in">size</span>(); <br>        Node&lt;KEY, VALUE&gt; *p;<br>        data[ind].<span class="hljs-built_in">insert</span>((p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>&lt;KEY, VALUE&gt;(key, value))); <br>        data_cnt += <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br><br>    Node&lt;KEY, VALUE&gt; *__find(KEY key) &#123;<br>        <span class="hljs-type">int</span> ind = <span class="hljs-built_in">hash_func</span>(key) % data.<span class="hljs-built_in">size</span>();<br>        Node&lt;KEY, VALUE&gt; *p = data[ind].<span class="hljs-built_in">next</span>();<br>        <span class="hljs-keyword">while</span> (p &amp;&amp; p-&gt;<span class="hljs-built_in">key</span>() != key) p = p-&gt;<span class="hljs-built_in">next</span>();<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br><br>    <span class="hljs-type">void</span> __expand() &#123;<br>        <span class="hljs-function">HashTable&lt;KEY, VALUE&gt; <span class="hljs-title">h</span><span class="hljs-params">(hash_func, <span class="hljs-number">2</span> * __size)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; __size; i++) &#123;<br>            Node&lt;KEY, VALUE&gt; *p = data[i].<span class="hljs-built_in">next</span>();<br>            <span class="hljs-keyword">while</span> (p) &#123;<br>                h.<span class="hljs-built_in">insert</span>(p-&gt;<span class="hljs-built_in">key</span>(), p-&gt;value);<br>                p = p-&gt;<span class="hljs-built_in">next</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">this</span>-&gt;__swap(h);<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br><br><br>    <span class="hljs-type">int</span> __size, data_cnt;<br>    vector&lt;Node&lt;KEY, VALUE&gt;&gt; data;<br>    HASH_FUNC_T hash_func;<br>&#125;;<br></code></pre></td></tr></table></figure>用模板实现后初始化哈希表时就能用<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">HashTable&lt;string, <span class="hljs-type">int</span>&gt; <span class="hljs-title">h1</span><span class="hljs-params">(FUNCC)</span></span>;<br></code></pre></td></tr></table></figure>FUNCC表示自定义哈希函数。]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>std::sort</title>
    <link href="/2022/05/01/2022-5-1-c-std-sort/"/>
    <url>/2022/05/01/2022-5-1-c-std-sort/</url>
    
    <content type="html"><![CDATA[<h4 id="STL的std-sort函数是基于Musser在1996年提出的内省排序（Introspective-sort）算法实现。这个算法是个缝合怪，它汲取了插入排序、堆排序以及快排的优点："><a href="#STL的std-sort函数是基于Musser在1996年提出的内省排序（Introspective-sort）算法实现。这个算法是个缝合怪，它汲取了插入排序、堆排序以及快排的优点：" class="headerlink" title="STL的std::sort函数是基于Musser在1996年提出的内省排序（Introspective sort）算法实现。这个算法是个缝合怪，它汲取了插入排序、堆排序以及快排的优点："></a>STL的std::sort函数是基于Musser在1996年提出的内省排序（Introspective sort）算法实现。这个算法是个缝合怪，它汲取了插入排序、堆排序以及快排的优点：<br></h4><p>针对大数据量，使用快排，时间复杂度是O(NlogN)；<br><br>若快排递归深度超过阈值__depth_limit ，改用堆排序，防止快排递归过深，同时保持时间复杂度仍是O(NlogN)；<br><br>当数据规模小于阈值_S_threshold时，改用插入排序。<br></p><h4 id="这里使用快速排序加插入排序实现。"><a href="#这里使用快速排序加插入排序实现。" class="headerlink" title="这里使用快速排序加插入排序实现。"></a>这里使用快速排序加插入排序实现。</h4><h2 id="std-sort的使用"><a href="#std-sort的使用" class="headerlink" title="std::sort的使用"></a>std::sort的使用</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> arr[<span class="hljs-number">100</span>], n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) cin &gt;&gt; arr[i];<br>    <span class="hljs-built_in">sort</span>(arr, arr + n); <span class="hljs-comment">// 默认从小到大排列</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) cout &lt;&lt; arr[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="可以自定义排序规则"><a href="#可以自定义排序规则" class="headerlink" title="可以自定义排序规则"></a>可以自定义排序规则</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp1</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123; <span class="hljs-comment">// 自定义函数</span><br>    <span class="hljs-keyword">return</span> a &gt; b;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CMP</span> &#123;               <span class="hljs-comment">// 自定义函数对象</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> a &lt; b;<br>    &#125;<br>&#125;;<br><br><span class="hljs-built_in">sort</span>(arr, arr + n, cmp1); <span class="hljs-comment">// 从大到小排列</span><br>CMP cmp2;<br><span class="hljs-built_in">sort</span>(arr, arr + n, cmp2); <span class="hljs-comment">// 传入函数对象</span><br><span class="hljs-built_in">sort</span>(arr, arr + n, [](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)&#123;<span class="hljs-keyword">return</span> a &lt; b;&#125;);      <span class="hljs-comment">// lamda表达式</span><br></code></pre></td></tr></table></figure><h2 id="sort实现"><a href="#sort实现" class="headerlink" title="sort实现"></a>sort实现</h2><h4 id="根据传入参数可以看出应该传入待排序数组的首位指针和排序规则，所以函数参数应该为int-first-int-last-function-lt-bool-int-int-gt-cmp。其中function默认从小到大排列。"><a href="#根据传入参数可以看出应该传入待排序数组的首位指针和排序规则，所以函数参数应该为int-first-int-last-function-lt-bool-int-int-gt-cmp。其中function默认从小到大排列。" class="headerlink" title="根据传入参数可以看出应该传入待排序数组的首位指针和排序规则，所以函数参数应该为int *first, int *last, function&lt;bool(int, int)&gt; cmp。其中function默认从小到大排列。"></a>根据传入参数可以看出应该传入待排序数组的首位指针和排序规则，所以函数参数应该为int *first, int *last, function&lt;bool(int, int)&gt; cmp。其中function默认从小到大排列。</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sort_</span><span class="hljs-params">(<span class="hljs-type">int</span> *first, <span class="hljs-type">int</span> *last, function&lt;<span class="hljs-type">bool</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; cmp = less&lt;<span class="hljs-type">int</span>&gt;())</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 快速排序</span><br>    <span class="hljs-keyword">if</span> (first &gt;= last) <span class="hljs-keyword">return</span> ;<br>    <span class="hljs-type">int</span> *x = first, *y = last - <span class="hljs-number">1</span>, base = *first;<br>    <span class="hljs-keyword">while</span> (x &lt; y)<br>    &#123;<br>        <span class="hljs-keyword">while</span> (x &lt; y &amp;&amp; <span class="hljs-built_in">cmp</span>(base, *y)) --y;<br>        <span class="hljs-keyword">if</span> (x &lt; y) *(x++) = *y;<br>        <span class="hljs-keyword">while</span> (x &lt; y &amp;&amp; <span class="hljs-built_in">cmp</span>(*x, base)) ++x;<br>        <span class="hljs-keyword">if</span> (x &lt; y) *(y--) = *x;<br>    &#125;<br>    *x = base;<br>    <span class="hljs-built_in">sort_</span>(first, x, cmp);<br>    <span class="hljs-built_in">sort_</span>(x + <span class="hljs-number">1</span>, last, cmp);<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="加入迭代器"><a href="#加入迭代器" class="headerlink" title="加入迭代器"></a>加入迭代器</h2><h4 id="根据stl的源码可知sort函数只接受两个-RandomAccessIterator（随机存取迭代器）。可以对上面的代码进行改进。同时加入threshold，当快速排序迭代的last-first-lt-threshold时，改用插入排序，另外快速排序使用单边递归减少递归次数。"><a href="#根据stl的源码可知sort函数只接受两个-RandomAccessIterator（随机存取迭代器）。可以对上面的代码进行改进。同时加入threshold，当快速排序迭代的last-first-lt-threshold时，改用插入排序，另外快速排序使用单边递归减少递归次数。" class="headerlink" title="根据stl的源码可知sort函数只接受两个_RandomAccessIterator（随机存取迭代器）。可以对上面的代码进行改进。同时加入threshold，当快速排序迭代的last - first &lt;= threshold时，改用插入排序，另外快速排序使用单边递归减少递归次数。"></a>根据stl的源码可知sort函数只接受两个_RandomAccessIterator（随机存取迭代器）。可以对上面的代码进行改进。同时加入threshold，当快速排序迭代的last - first &lt;= threshold时，改用插入排序，另外快速排序使用单边递归减少递归次数。</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sort_</span><span class="hljs-params">(RandomIter first, RandomIter last, function&lt;<span class="hljs-type">bool</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; cmp = less&lt;<span class="hljs-type">int</span>&gt;())</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">intro_loop</span>(first, last, cmp); <span class="hljs-comment">// 用快速排序分为16个元素一组</span><br>    <span class="hljs-built_in">insert_sort</span>(first, last, cmp); <span class="hljs-comment">// 对快速排序后的每组16个元素进行插入排序</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="快排的实现"><a href="#快排的实现" class="headerlink" title="快排的实现"></a>快排的实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">intro_loop</span><span class="hljs-params">(RandomIter first, RandomIter last, function&lt;<span class="hljs-type">bool</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; cmp = less&lt;<span class="hljs-type">int</span>&gt;())</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (last - first &gt; threshold)<br>    &#123;<br>        RandomIter x = first, y = last - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> base = *first;<br>        <span class="hljs-keyword">do</span>&#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-built_in">cmp</span>(*x, base)) ++x;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-built_in">cmp</span>(base, *y)) --y;<br>            <span class="hljs-keyword">if</span> (x &lt; y)<br>            &#123;<br>                <span class="hljs-built_in">swap</span>(*x, *y);<br>                ++x, --y;<br>            &#125;<br>        &#125;<span class="hljs-keyword">while</span> (x &lt;= y);<br>        <span class="hljs-built_in">intro_loop</span>(x, last, cmp); <span class="hljs-comment">// 单边递归</span><br>        last = y + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="插入排序实现"><a href="#插入排序实现" class="headerlink" title="插入排序实现"></a>插入排序实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert_sort</span><span class="hljs-params">(RandomIter first, RandomIter last, function&lt;<span class="hljs-type">bool</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; cmp = less&lt;<span class="hljs-type">int</span>&gt;())</span></span><br><span class="hljs-function"></span>&#123;<br>    RandomIter ind = first;<br>    <span class="hljs-keyword">for</span> (RandomIter x = first + <span class="hljs-number">1</span>; x &lt; last; ++x)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">cmp</span>(*x, *ind)) ind = x;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (ind != first)<br>    &#123;<br>        <span class="hljs-built_in">swap</span>(*ind, *(ind - <span class="hljs-number">1</span>));<br>        --ind;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (RandomIter x = first + <span class="hljs-number">2</span>; x &lt; last; ++x)<br>    &#123;<br>        RandomIter j = x;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-built_in">cmp</span>(*j, *(j - <span class="hljs-number">1</span>)))<br>        &#123;<br>            <span class="hljs-built_in">swap</span>(*j, *(j - <span class="hljs-number">1</span>));<br>            --j;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="随机迭代器的实现"><a href="#随机迭代器的实现" class="headerlink" title="随机迭代器的实现"></a>随机迭代器的实现</h4><p>1、迭代器在函数中应该和指针一样使用。所以迭代器应该定义为一类指针对象。<br><br>2、在sort函数中传入的是int*类型的指针，所以随机迭代器的构造函数应该将指针转为自身的成员变量存储。<br><br>3、迭代器应该支持指针的各种功能。<br></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RandomIter</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">RandomIter</span>(<span class="hljs-type">int</span> *ptr) : <span class="hljs-built_in">ptr</span>(ptr) &#123;&#125;<br><br>    <span class="hljs-type">int</span> &amp;<span class="hljs-keyword">operator</span>*() &#123; <span class="hljs-keyword">return</span> *ptr; &#125; <span class="hljs-comment">// 重载*</span><br><br>    RandomIter <span class="hljs-keyword">operator</span>+(<span class="hljs-type">int</span> x) &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">RandomIter</span>(ptr + x); &#125; <span class="hljs-comment">// 支持迭代器 +/- 整数</span><br>    RandomIter <span class="hljs-keyword">operator</span>-(<span class="hljs-type">int</span> x) &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">RandomIter</span>(ptr - x); &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-keyword">operator</span>-(<span class="hljs-type">const</span> RandomIter &amp;iter) &#123; <span class="hljs-keyword">return</span> ptr - iter.ptr; &#125; <span class="hljs-comment">// 迭代器之间运算</span><br><br>    RandomIter &amp;<span class="hljs-keyword">operator</span>++() &#123; ++ptr; <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; &#125; <span class="hljs-comment">//前++</span><br>    RandomIter &amp;<span class="hljs-keyword">operator</span>--() &#123; --ptr; <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; &#125; <span class="hljs-comment">// 前--</span><br><br>    <span class="hljs-comment">// 比较运算符重载</span><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> RandomIter &amp;iter) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> ptr &lt; iter.ptr; &#125;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;(<span class="hljs-type">const</span> RandomIter &amp;iter) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> iter &lt; *<span class="hljs-keyword">this</span>; &#125;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;=(<span class="hljs-type">const</span> RandomIter &amp;iter) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> !(*<span class="hljs-keyword">this</span> &gt; iter); &#125;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;=(<span class="hljs-type">const</span> RandomIter &amp;iter) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> !(*<span class="hljs-keyword">this</span> &lt; iter); &#125;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> RandomIter &amp;iter) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> !(*<span class="hljs-keyword">this</span> &gt; iter) &amp;&amp; !(*<span class="hljs-keyword">this</span> &lt; iter); &#125;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> RandomIter &amp;iter) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> !(*<span class="hljs-keyword">this</span> == (iter.ptr)); &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> *ptr;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++返回值优化</title>
    <link href="/2022/04/19/2022-4-19-c-%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BC%98%E5%8C%96/"/>
    <url>/2022/04/19/2022-4-19-c-%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="C-的返回值优化"><a href="#C-的返回值优化" class="headerlink" title="C++的返回值优化"></a>C++的返回值优化</h1><h4 id="RVO的全称是Return-Value-Optimization。RVO是一种编译器优化技术，可以把通过函数返回创建的临时对象给”去掉”，然后可以达到少调用拷贝构造的操作目的，它是C-11标准的一部分。"><a href="#RVO的全称是Return-Value-Optimization。RVO是一种编译器优化技术，可以把通过函数返回创建的临时对象给”去掉”，然后可以达到少调用拷贝构造的操作目的，它是C-11标准的一部分。" class="headerlink" title="RVO的全称是Return Value Optimization。RVO是一种编译器优化技术，可以把通过函数返回创建的临时对象给”去掉”，然后可以达到少调用拷贝构造的操作目的，它是C++11标准的一部分。"></a>RVO的全称是Return Value Optimization。RVO是一种编译器优化技术，可以把通过函数返回创建的临时对象给”去掉”，然后可以达到少调用拷贝构造的操作目的，它是C++11标准的一部分。<br></h4><h4 id="如果编译器明确知道函数会返回哪一个局部对象，那么编译器会把存储这个局部对象的地址和存储返回值临时对象的地址进行复用，也就是说避免了从局部对象到临时对象的拷贝操作。这就是RVO。"><a href="#如果编译器明确知道函数会返回哪一个局部对象，那么编译器会把存储这个局部对象的地址和存储返回值临时对象的地址进行复用，也就是说避免了从局部对象到临时对象的拷贝操作。这就是RVO。" class="headerlink" title="如果编译器明确知道函数会返回哪一个局部对象，那么编译器会把存储这个局部对象的地址和存储返回值临时对象的地址进行复用，也就是说避免了从局部对象到临时对象的拷贝操作。这就是RVO。"></a>如果编译器明确知道函数会返回哪一个局部对象，那么编译器会把存储这个局部对象的地址和存储返回值临时对象的地址进行复用，也就是说避免了从局部对象到临时对象的拷贝操作。这就是RVO。</h4><h1 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;default constructor&quot;</span> &lt;&lt; endl; &#125;<br><br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> x) &#123; cout &lt;&lt; <span class="hljs-string">&quot;param constructor&quot;</span> &lt;&lt; endl; &#125;<br><br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">const</span> A &amp;a) &#123; cout &lt;&lt; <span class="hljs-string">&quot;copy constructor&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><span class="hljs-function">A <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">A <span class="hljs-title">temp</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-keyword">return</span> temp;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    A a = <span class="hljs-built_in">func</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h4><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi">param <span class="hljs-function"><span class="hljs-keyword">constructor</span></span><br></code></pre></td></tr></table></figure><h4 id="程序的预期运行结果应该是："><a href="#程序的预期运行结果应该是：" class="headerlink" title="程序的预期运行结果应该是："></a>程序的预期运行结果应该是：</h4><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs delphi">param <span class="hljs-function"><span class="hljs-keyword">constructor</span></span><br><span class="hljs-function"><span class="hljs-title">copy</span> <span class="hljs-title">constructor</span></span><br><span class="hljs-function"><span class="hljs-title">copy</span> <span class="hljs-title">constructor</span></span><br></code></pre></td></tr></table></figure><h4 id="程序预期的运行流程"><a href="#程序预期的运行流程" class="headerlink" title="程序预期的运行流程"></a>程序预期的运行流程</h4><h4 id="1、开辟对象a的数据区，调用函数func"><a href="#1、开辟对象a的数据区，调用函数func" class="headerlink" title="1、开辟对象a的数据区，调用函数func();"></a>1、开辟对象a的数据区，调用函数func();</h4><h4 id="2、开辟对象temp的数据区，调用temp的构造函数：输出param-constructor；"><a href="#2、开辟对象temp的数据区，调用temp的构造函数：输出param-constructor；" class="headerlink" title="2、开辟对象temp的数据区，调用temp的构造函数：输出param constructor；"></a>2、开辟对象temp的数据区，调用temp的构造函数：输出param constructor；</h4><h4 id="3、使用temp调用临时匿名变量的拷贝构造函数：输出copy-constructor；"><a href="#3、使用temp调用临时匿名变量的拷贝构造函数：输出copy-constructor；" class="headerlink" title="3、使用temp调用临时匿名变量的拷贝构造函数：输出copy constructor；"></a>3、使用temp调用临时匿名变量的拷贝构造函数：输出copy constructor；</h4><h4 id="4、销毁temp对象；"><a href="#4、销毁temp对象；" class="headerlink" title="4、销毁temp对象；"></a>4、销毁temp对象；</h4><h4 id="5、使用临时匿名变量调用a的拷贝构造函数：输出copy-constructor；"><a href="#5、使用临时匿名变量调用a的拷贝构造函数：输出copy-constructor；" class="headerlink" title="5、使用临时匿名变量调用a的拷贝构造函数：输出copy constructor；"></a>5、使用临时匿名变量调用a的拷贝构造函数：输出copy constructor；</h4><h4 id="6、销毁临时匿名变量，销毁a对象；"><a href="#6、销毁临时匿名变量，销毁a对象；" class="headerlink" title="6、销毁临时匿名变量，销毁a对象；  "></a>6、销毁临时匿名变量，销毁a对象；<br> <br> <br></h4><h4 id="验证程序运行步骤-添加一些语句："><a href="#验证程序运行步骤-添加一些语句：" class="headerlink" title="验证程序运行步骤,添加一些语句："></a>验证程序运行步骤,添加一些语句：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>() &#123; cout &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; <span class="hljs-string">&quot; : default constructor&quot;</span> &lt;&lt; endl; &#125;<br>    <br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> x) &#123; cout &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; <span class="hljs-string">&quot; : param constructor&quot;</span> &lt;&lt; endl; &#125;<br>    <br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">const</span> A &amp;a) &#123; cout &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; <span class="hljs-string">&quot; : copy constructor&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><span class="hljs-function">A <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">A <span class="hljs-title">temp</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;object temp : &quot;</span> &lt;&lt; &amp;temp &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> temp;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    A a = <span class="hljs-built_in">func</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;object a : &quot;</span> &lt;&lt; &amp;a &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h4><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-number">0</span>x48617ffcdf : param <span class="hljs-function"><span class="hljs-keyword">constructor</span></span><br><span class="hljs-function"><span class="hljs-title">object</span> <span class="hljs-title">temp</span> :</span> <span class="hljs-number">0</span>x48617ffcdf<br><span class="hljs-keyword">object</span> a : <span class="hljs-number">0</span>x48617ffcdf<br></code></pre></td></tr></table></figure><h4 id="发现temp和a对象的地址相同，编译器进行了优化：直接将temp对象改为a对象。"><a href="#发现temp和a对象的地址相同，编译器进行了优化：直接将temp对象改为a对象。" class="headerlink" title="发现temp和a对象的地址相同，编译器进行了优化：直接将temp对象改为a对象。"></a>发现temp和a对象的地址相同，编译器进行了优化：直接将temp对象改为a对象。<br></h4><h4 id="可以在编译时加上-下面语句主动关闭返回值优化："><a href="#可以在编译时加上-下面语句主动关闭返回值优化：" class="headerlink" title="可以在编译时加上,下面语句主动关闭返回值优化："></a>可以在编译时加上,下面语句主动关闭返回值优化：</h4><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-fno-elide-constructors</span><br></code></pre></td></tr></table></figure><h4 id="输出结果："><a href="#输出结果：" class="headerlink" title="输出结果："></a>输出结果：</h4><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-number">0</span>x7ffea7e81e0f : param <span class="hljs-keyword">constructor</span><br><span class="hljs-title function_">object</span> <span class="hljs-title function_">temp</span> : <span class="hljs-number">0</span>x7ffea7e81e0f<br><span class="hljs-number">0</span>x7ffea7e81e2f : <span class="hljs-keyword">copy</span> <span class="hljs-keyword">constructor</span><br>0<span class="hljs-title function_">x7ffea7e81e2e</span> : <span class="hljs-keyword">copy</span> <span class="hljs-keyword">constructor</span><br><span class="hljs-title function_">object</span> <span class="hljs-title function_">a</span> : <span class="hljs-number">0</span>x7ffea7e81e2e<br></code></pre></td></tr></table></figure><h4 id="和上面设想的程序运行流程相同。"><a href="#和上面设想的程序运行流程相同。" class="headerlink" title="和上面设想的程序运行流程相同。"></a>和上面设想的程序运行流程相同。</h4>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基数排序</title>
    <link href="/2022/04/11/2022-4-11-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/04/11/2022-4-11-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="一、复杂度分析"><a href="#一、复杂度分析" class="headerlink" title="一、复杂度分析"></a>一、复杂度分析</h1><p>基数排序时间复杂度为O(d * (n + r))，其中d为待排序数组的最多位数，r为基数，即进制数，n为待排序数字的个数。<br>空间复杂度为O(n + r)。  基数排序是稳定的。</p><h1 id="二、基数排序过程"><a href="#二、基数排序过程" class="headerlink" title="二、基数排序过程"></a>二、基数排序过程</h1><h4 id="①-假设待排序数组最多只有两位，先对个位进行处理。"><a href="#①-假设待排序数组最多只有两位，先对个位进行处理。" class="headerlink" title="① 假设待排序数组最多只有两位，先对个位进行处理。"></a>① 假设待排序数组最多只有两位，先对个位进行处理。</h4><p><img src="/img/2022-4-11-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/1.png" alt="1"></p><h5 id="Ⅰ先对个位的数字进行计数"><a href="#Ⅰ先对个位的数字进行计数" class="headerlink" title="Ⅰ先对个位的数字进行计数"></a>Ⅰ先对个位的数字进行计数</h5><p>个位为1：出现4次<br><br>个位为2：出现2次<br><br>个位为3：出现1次<br></p><h5 id="Ⅱ-将统计的结果看成一个数组"><a href="#Ⅱ-将统计的结果看成一个数组" class="headerlink" title="Ⅱ 将统计的结果看成一个数组"></a>Ⅱ 将统计的结果看成一个数组</h5><p><img src="/img/2022-4-11-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/2.png" alt="2"><br><br></p><h5 id="Ⅲ-求这个数组的前缀和"><a href="#Ⅲ-求这个数组的前缀和" class="headerlink" title="Ⅲ 求这个数组的前缀和"></a>Ⅲ 求这个数组的前缀和</h5><p><img src="/img/2022-4-11-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/3.png" alt="3"></p><h5 id="Ⅳ-当求完这个数组的前缀和后，可以得到排列完个位后数组的放置方法"><a href="#Ⅳ-当求完这个数组的前缀和后，可以得到排列完个位后数组的放置方法" class="headerlink" title="Ⅳ 当求完这个数组的前缀和后，可以得到排列完个位后数组的放置方法"></a>Ⅳ 当求完这个数组的前缀和后，可以得到排列完个位后数组的放置方法</h5><p><img src="/img/2022-4-11-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/4.png" alt="4"></p><p>由前缀和数组可以得到，第1到4的位置要放个位为1的数字，第5到6放个位为2的数子，第7的位置放个位为3的数字。<br><br>它们分别以前缀和数组的值来划分。换句话说：前缀和数组的值，表示这个值的KEY在排序后数组所在区域的末尾位置（尾坐标）。</p><h5 id="Ⅴ-对待排序的数组从后向前遍历"><a href="#Ⅴ-对待排序的数组从后向前遍历" class="headerlink" title="Ⅴ 对待排序的数组从后向前遍历"></a>Ⅴ 对待排序的数组从后向前遍历</h5><p><img src="/img/2022-4-11-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/5.png" alt="5"></p><p>按遍历的每个数的个位放入待放置的数组。如此时遍历到“31”，将“31”放入4位置，继续向前到“32”，将它放入6位置，“11”放到3位置。以此类推，直至放置完成。<br><br><img src="/img/2022-4-11-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/6.png" alt="6"></p><p><br><br><br><br></p><p>第一轮排序完成</p><h5 id="Ⅵ-再对十位上的数字进行排序，流程和上面一样。先对十位上的数字进行计数。"><a href="#Ⅵ-再对十位上的数字进行排序，流程和上面一样。先对十位上的数字进行计数。" class="headerlink" title="Ⅵ 再对十位上的数字进行排序，流程和上面一样。先对十位上的数字进行计数。"></a>Ⅵ 再对十位上的数字进行排序，流程和上面一样。先对十位上的数字进行计数。</h5><p>十位为1：出现2次<br><br>十位为2：出现3次<br><br>十位为3：出现2次<br></p><h5 id="将统计结果看成数组，并求其前缀和"><a href="#将统计结果看成数组，并求其前缀和" class="headerlink" title="将统计结果看成数组，并求其前缀和"></a>将统计结果看成数组，并求其前缀和</h5><p><img src="/img/2022-4-11-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/7.png" alt="7"></p><h5 id="得到放置方法，并再从后往前遍历数组进行放置"><a href="#得到放置方法，并再从后往前遍历数组进行放置" class="headerlink" title="得到放置方法，并再从后往前遍历数组进行放置"></a>得到放置方法，并再从后往前遍历数组进行放置</h5><p><img src="/img/2022-4-11-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/8.png" alt="8"></p><h4 id="排序完成"><a href="#排序完成" class="headerlink" title="排序完成"></a>排序完成</h4><h1 id="三、代码实现"><a href="#三、代码实现" class="headerlink" title="三、代码实现"></a>三、代码实现</h1><p>基数排序主要对整型数组进行排序。一个整型为32位，可以将其分为前16位和后16位，对应上面的个位和十位分开进行排序。<br><br>16位二进制可表示65536种状态，所以申请的计数数组的大小为65536。同时声明排序过程中的临时数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">radix_sort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> cnt[<span class="hljs-number">65536</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">temp</span><span class="hljs-params">(nums.size())</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>排序应分为两轮进行，分别对低16位和高16位进行基数排序。<br><br>扫描nums数组，取低16位，在cnt数组记录出现的次数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : nums) cnt[x &amp; <span class="hljs-number">0xffff</span>] += <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 也可以 for (int i : nums) cnt[x % 65536] += 1; </span><br><span class="hljs-comment">//这相当于将nums数组中的数看成65536进制，取它的个位。</span><br></code></pre></td></tr></table></figure><p>对cnt数组求它的前缀和。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">65536</span>; i++) cnt[i] += cnt[i - <span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure><p>从后向前扫描nums数组，将其放入temp数组中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) temp[--cnt[nums[i] % <span class="hljs-number">65536</span>]] = nums[i];<br><span class="hljs-comment">// nums[i] % 65536 对当前数字取低16位</span><br><span class="hljs-comment">// cnt[nums[i] % 65536] 当前数字应该放置的位置</span><br><span class="hljs-comment">// --cnt[nums[i] % 65536] 表示当前数字应该放置在temp数组的位置的下标（KEY）</span><br></code></pre></td></tr></table></figure><h4 id="高16位的排序与上面相同，全部代码如下"><a href="#高16位的排序与上面相同，全部代码如下" class="headerlink" title="高16位的排序与上面相同，全部代码如下"></a>高16位的排序与上面相同，全部代码如下</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">radix_sort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> cnt[<span class="hljs-number">65536</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">temp</span><span class="hljs-params">(nums.size())</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : nums) cnt[x &amp; <span class="hljs-number">0xffff</span>] += <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">65536</span>; i++) cnt[i] += cnt[i - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) temp[--cnt[nums[i] % <span class="hljs-number">65536</span>]] = nums[i];<br>    <span class="hljs-built_in">memset</span>(cnt, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(cnt));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : temp) cnt[x / <span class="hljs-number">65536</span>] += <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">65536</span>; i++) cnt[i] += cnt[i - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = temp.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;=<span class="hljs-number">0</span>; i--) nums[--cnt[temp[i] / <span class="hljs-number">65536</span>]] = temp[i];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>红黑树：C++</title>
    <link href="/2022/03/30/2022-03-29-c-%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/03/30/2022-03-29-c-%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="C-红黑树简易实现"><a href="#C-红黑树简易实现" class="headerlink" title="C++红黑树简易实现"></a>C++红黑树简易实现</h1><p> 红黑树是一种二叉搜索树，但在每个结点上增加了一个存储位用于表示结点的颜色，这个颜色可以是红色的，也可以是黑色的，因此我们称之为红黑树。</p><h2 id="一、红黑树满足的条件"><a href="#一、红黑树满足的条件" class="headerlink" title="一、红黑树满足的条件"></a>一、红黑树满足的条件</h2><p> 1、每个节点非黑即红<br><br> 2、根节点必黑<br><br> 3、叶节点（NIL）必黑<br><br> 4、红节点的两个子节点必黑<br><br> 5、从根节点出发到所有叶节点路径上，黑色节点数量相同<br></p><p>对于红黑树结构简单定义的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>    <span class="hljs-type">int</span> key;<br>    <span class="hljs-type">int</span> color; <span class="hljs-comment">// 0 red; 1 black; 2 double black</span><br>    TreeNode *left;<br>    TreeNode *right;<br>    <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">key</span>(x), <span class="hljs-built_in">left</span>(<span class="hljs-literal">NULL</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">NULL</span>) &#123;&#125;<br>    <span class="hljs-built_in">TreeNode</span>() &#123;&#125;<br>&#125;;<span class="hljs-comment">// 这里的double black颜色是用来方便删除调整的</span><br></code></pre></td></tr></table></figure><h2 id="二、红黑树的插入和删除策略"><a href="#二、红黑树的插入和删除策略" class="headerlink" title="二、红黑树的插入和删除策略"></a>二、红黑树的插入和删除策略</h2><p> 红黑树的插入和删除策略可以参考平衡二叉搜索树的插入和删除。</p><h2 id="三、红黑树的调整策略"><a href="#三、红黑树的调整策略" class="headerlink" title="三、红黑树的调整策略"></a>三、红黑树的调整策略</h2><p> 调整策略分为插入调整和删除调整，其中插入调整可分为两大情况，删除调整可分为三大情况，下面介绍这五种情况。</p><h3 id="①插入调整"><a href="#①插入调整" class="headerlink" title="①插入调整"></a><font color=red>①插入调整</font></h3><p> 1、为了满足条件5（从根节点出发到所有叶节点路径上，黑色节点数量相同）插入的节点应该都为红节点。</p><p> 2、若插入后出现连着两个红色，此时不满足条件4（红节点的两个子节点必黑），应进行插入调整。</p><h4 id="插入调整应站在祖父节点的角度"><a href="#插入调整应站在祖父节点的角度" class="headerlink" title="插入调整应站在祖父节点的角度"></a>插入调整应站在祖父节点的角度</h4><p><img src="/img/C++%E7%BA%A2%E9%BB%91%E6%A0%91/1.png" alt="1"></p><p>如上图节点“6”和“8”发生冲突，需站在“5”节点向下看。<font color=red>即当我们在父节点发现自己与子节点发生冲突，此时不用进行调整。</font></p><h4 id="情况1："><a href="#情况1：" class="headerlink" title="情况1："></a><font color=green>情况1：</font></h4><p><img src="/img/C++%E7%BA%A2%E9%BB%91%E6%A0%91/1.png" alt="1"></p><p> 根节点的两个子节点为红，其中一个子节点的一个子节点也为红。冲突！</p><p>调整方法：将根节点与它的两子节点改变颜色，从原来的黑、红、红，改为红、黑、黑<br><img src="/img/C++%E7%BA%A2%E9%BB%91%E6%A0%91/2.png" alt="2"></p><p>调整完后可以看到仍然满足<font color=bulue>从根节点出发到所有叶节点路径上，黑色节点数量相同。</font></p><h4 id="情况2："><a href="#情况2：" class="headerlink" title="情况2："></a><font color=green>情况2：</font></h4><p><img src="/img/C++%E7%BA%A2%E9%BB%91%E6%A0%91/3.png" alt="3"></p><p> 根节点的两个子节点一黑一红，红色子节点的一个子节点也为红。冲突！</p><p>冲突的两个红节点都在根节点的左边，这种情况我们称为“LL”类型的冲突。</p><p>调整方法：抓住根节点进行一个大右旋<br><img src="/img/C++%E7%BA%A2%E9%BB%91%E6%A0%91/4.png" alt="4"></p><p>右旋后就是调整颜色了，直接修改新根节点和其两个子节点的颜色即可，可以采用：红色上浮、红色下潜。<br><img src="/img/C++%E7%BA%A2%E9%BB%91%E6%A0%91/5.png" alt="5"><br><img src="/img/C++%E7%BA%A2%E9%BB%91%E6%A0%91/6.png" alt="6"></p><p>调整后仍然满足红黑树的定义。两种方法都可使用。</p><p> 如果冲突的两个红节点是“LR”类型，即第一个红节点在根节点左边，第二个红节点在第一个红节点的右边。我们可以抓住第一个在根节点左边的红节点进行小左旋，此时即转化为“LL”类型冲突。</p><p> 同理，“RR”类型的冲突我们可以仿照“LL”类型的冲突，先抓住根节点进行大左旋，再调整颜色即可。而“RL”类型与“LR”类型同理，进行一个小右旋即可转化为“RR”类型。</p><h3 id="②删除调整"><a href="#②删除调整" class="headerlink" title="②删除调整"></a><font color=red>②删除调整</font></h3><h4 id="删除调整的注意事项："><a href="#删除调整的注意事项：" class="headerlink" title="删除调整的注意事项："></a>删除调整的注意事项：</h4><p> 1、删除红色节点对树没影响。<br><br> 2、度为1的黑色节点，若有唯一子节点，一定是红色。<br><br> 3、删除度为1的黑色节点，不会产生删除调整（删完后让他子节点变黑就行）。<br><br> 4、删除度为0的黑色节点，会产生一个双重黑的NIL节点（为了满足调整前后，从根节点出发到所有叶节点路径上，黑色节点数量相同）。<br><br> 5、删除调整，就是为了干掉双重黑。<br><br> 6、删除度为2的节点可以转化为度为0或1的节点。（参考平衡二叉搜索树）<br></p><h4 id="删除调整要站在双重黑节点的父节点的角度向下进行调整。"><a href="#删除调整要站在双重黑节点的父节点的角度向下进行调整。" class="headerlink" title="删除调整要站在双重黑节点的父节点的角度向下进行调整。"></a>删除调整要站在双重黑节点的父节点的角度向下进行调整。</h4><p> 如下图，我们将双重黑的节点用一个四角形标记。<br><img src="/img/C++%E7%BA%A2%E9%BB%91%E6%A0%91/7.png" alt="7"></p><p> 在进行调整时，要站在“43”节点的位置进行调整。</p><h4 id="情况1：-1"><a href="#情况1：-1" class="headerlink" title="情况1："></a><font color=green>情况1：</font></h4><p><img src="/img/C++%E7%BA%A2%E9%BB%91%E6%A0%91/7.png" alt="7"></p><p>双重黑节点的兄弟节点是黑色，兄弟节点下面的两个子节点也是黑色。</p><p>调整方法：父节点增加一重黑色，父节点的两个子节点（双重黑与兄弟节点）都减一层黑色。<br><img src="/img/C++%E7%BA%A2%E9%BB%91%E6%A0%91/8.png" alt="8"></p><h4 id="情况2：-1"><a href="#情况2：-1" class="headerlink" title="情况2："></a><font color=green>情况2：</font></h4><p>双重黑节点的兄弟节点是黑色，但兄弟节点下面有红色子节点。<br><img src="/img/C++%E7%BA%A2%E9%BB%91%E6%A0%91/9.png" alt="9"></p><p>如上图，兄弟节点在右边，且兄弟节点的右子节点为红色，定义为“RR”类型冲突。注意：只要右子节点为红色，都是“RR”类型，只有左子节点单独为红是才是“RL”类型。</p><p>调整方法：“RR”类型抓住根节点左旋，将新根改为原根的颜色，再将新根的两个子节点改成黑色。“LL”类型同理，抓住根节点右旋。。。<br><img src="/img/C++%E7%BA%A2%E9%BB%91%E6%A0%91/10.png" alt="10"></p><p>如果是“RL”类型，只需抓住兄弟节点进行小右旋，交换新根节点与原根节点的颜色，即可转换为“RR”类型。同理“LR”类型只需抓住兄弟节点进行小左旋，交换新根节点与原根节点的颜色，即可转换为“LL”类型。<br><img src="/img/C++%E7%BA%A2%E9%BB%91%E6%A0%91/11.png" alt="11"></p><h4 id="情况3："><a href="#情况3：" class="headerlink" title="情况3："></a><font color=green>情况3：</font></h4><p>双重黑的兄弟节点是红色。<br><img src="/img/C++%E7%BA%A2%E9%BB%91%E6%A0%91/12.png" alt="12"></p><p>调整方法：通过旋转将红色节点转到根节点，再将此时的根节点变黑，原来的根节点变红，这样兄弟节点就变黑了，就能转变为上面的两种情况。<br><img src="/img/C++%E7%BA%A2%E9%BB%91%E6%A0%91/13.png" alt="13"></p><h2 id="红黑树简单实现代码"><a href="#红黑树简单实现代码" class="headerlink" title="红黑树简单实现代码"></a>红黑树简单实现代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>    <span class="hljs-type">int</span> key;<br>    <span class="hljs-type">int</span> color; <span class="hljs-comment">// 0 red; 1 black; 2 double black</span><br>    TreeNode *left;<br>    TreeNode *right;<br>    <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">key</span>(x), <span class="hljs-built_in">left</span>(<span class="hljs-literal">NULL</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">NULL</span>) &#123;&#125;<br>    <span class="hljs-built_in">TreeNode</span>() &#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">// 虚拟空节点</span><br>TreeNode __NIL;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NIL (&amp;__NIL)</span><br>__attribute__((constructor))<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init_NIL</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    NIL-&gt;key = <span class="hljs-number">0</span>;<br>    NIL-&gt;color = <span class="hljs-number">1</span>;<br>    NIL-&gt;left = NIL-&gt;right = NIL;<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br><br><span class="hljs-comment">// 创建一个等待插入的红节点</span><br><span class="hljs-function">TreeNode *<span class="hljs-title">getNewNode</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span></span><br><span class="hljs-function"></span>&#123;<br>    TreeNode *node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(key);<br>    node-&gt;color = <span class="hljs-number">0</span>;<br>    node-&gt;left = node-&gt;right = NIL;<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br><br><span class="hljs-comment">// 找到树中某个节点的前驱</span><br><span class="hljs-function">TreeNode *<span class="hljs-title">predecessor</span><span class="hljs-params">(TreeNode *root)</span></span><br><span class="hljs-function"></span>&#123;<br>    TreeNode *temp = root-&gt;left;<br>    <span class="hljs-keyword">while</span> (temp-&gt;right != NIL) temp = temp-&gt;right;<br>    <span class="hljs-keyword">return</span> temp;<br>&#125;<br><br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">(TreeNode *root)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (root == NIL) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">clear</span>(root-&gt;left);<br>    <span class="hljs-built_in">clear</span>(root-&gt;right);<br>    <span class="hljs-built_in">free</span>(root);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">has_red_child</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123; <span class="hljs-keyword">return</span> root-&gt;right-&gt;color == <span class="hljs-number">0</span> || root-&gt;left-&gt;color == <span class="hljs-number">0</span>; &#125;<br><br><span class="hljs-comment">// 左旋</span><br><span class="hljs-function">TreeNode *<span class="hljs-title">left_rotate</span><span class="hljs-params">(TreeNode *root)</span></span><br><span class="hljs-function"></span>&#123;<br>    TreeNode *temp = root-&gt;right;<br>    root-&gt;right = temp-&gt;left;<br>    temp-&gt;left = root;<br>    <span class="hljs-keyword">return</span> temp;<br>&#125;<br><span class="hljs-function">TreeNode *<span class="hljs-title">right_rotate</span><span class="hljs-params">(TreeNode *root)</span></span><br><span class="hljs-function"></span>&#123;<br>    TreeNode *temp = root-&gt;left;<br>    root-&gt;left = temp-&gt;right;<br>    temp-&gt;right = root;<br>    <span class="hljs-keyword">return</span> temp;<br>&#125;<br><br><span class="hljs-comment">// 删除调整函数</span><br><span class="hljs-function">TreeNode *<span class="hljs-title">erase_maintain</span><span class="hljs-params">(TreeNode *root)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (root-&gt;left-&gt;color != <span class="hljs-number">2</span> &amp;&amp; root-&gt;right-&gt;color != <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> root;<br>    <span class="hljs-comment">// 找到双重黑节点了</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">has_red_child</span>(root)) <span class="hljs-comment">// 兄弟节点是红色情况</span><br>    &#123;<br>        <span class="hljs-type">int</span> flag = <span class="hljs-number">0</span>;<br>        root-&gt;color = <span class="hljs-number">0</span>; <span class="hljs-comment">// 原根节点改红色</span><br>        <span class="hljs-keyword">if</span> (root-&gt;left-&gt;color == <span class="hljs-number">0</span>)<br>        &#123;<br>            root = <span class="hljs-built_in">right_rotate</span>(root); flag = <span class="hljs-number">1</span>; <span class="hljs-comment">//右旋，应向右递归</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <br>        &#123;<br>            root = <span class="hljs-built_in">left_rotate</span>(root); flag = <span class="hljs-number">2</span>; <span class="hljs-comment">// 左旋，向左递归</span><br>        &#125;<br>        root-&gt;color = <span class="hljs-number">1</span>; <span class="hljs-comment">// 新根节点改黑色</span><br>        <span class="hljs-keyword">if</span> (flag == <span class="hljs-number">1</span>) root-&gt;right = <span class="hljs-built_in">erase_maintain</span>(root-&gt;right);<br>        <span class="hljs-keyword">else</span> root-&gt;left = <span class="hljs-built_in">erase_maintain</span>(root-&gt;left);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-comment">// 兄弟节点是黑色的情况</span><br>    <br>    <span class="hljs-comment">// 情况一，兄弟节点的两个子节点都是黑色</span><br>    <span class="hljs-keyword">if</span> ((root-&gt;left-&gt;color == <span class="hljs-number">2</span> &amp;&amp; !<span class="hljs-built_in">has_red_child</span>(root-&gt;right)) ||<br>        (root-&gt;right-&gt;color == <span class="hljs-number">2</span> &amp;&amp; !<span class="hljs-built_in">has_red_child</span>(root-&gt;left)))<br>    &#123;<br>        root-&gt;left-&gt;color -= <span class="hljs-number">1</span>;<br>        root-&gt;right-&gt;color -= <span class="hljs-number">1</span>;<br>        root-&gt;color += <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (root-&gt;left-&gt;color == <span class="hljs-number">2</span>) <span class="hljs-comment">// 左子树是双重黑</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (root-&gt;right-&gt;right-&gt;color != <span class="hljs-number">0</span>) <span class="hljs-comment">// 此时就是的RL类型</span><br>        &#123;<br>          root-&gt;right-&gt;color = <span class="hljs-number">0</span>;<br>          root = <span class="hljs-built_in">right_rotate</span>(root-&gt;right); <span class="hljs-comment">// 小右旋</span><br>          root-&gt;right-&gt;color = <span class="hljs-number">1</span>;<br>        &#125;<br>        root = <span class="hljs-built_in">left_rotate</span>(root);<br>        root-&gt;color = root-&gt;left-&gt;color;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-comment">// 右子树是双重黑</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (root-&gt;left-&gt;left-&gt;color != <span class="hljs-number">0</span>) <span class="hljs-comment">// 此时就是LR类型</span><br>        &#123;<br>          root-&gt;left-&gt;color = <span class="hljs-number">0</span>;<br>          root = <span class="hljs-built_in">left_rotate</span>(root-&gt;left); <span class="hljs-comment">// 小左旋</span><br>          root-&gt;left-&gt;color = <span class="hljs-number">1</span>;<br>        &#125;<br>        root = <span class="hljs-built_in">right_rotate</span>(root);<br>        root-&gt;color = root-&gt;right-&gt;color;<br>    &#125;<br>    root-&gt;left-&gt;color = root-&gt;right-&gt;color = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> root;<br>    <br><br>&#125;<br><br>TreeNode *__erase(TreeNode *root, <span class="hljs-type">int</span> key)<br>&#123;<br>    <span class="hljs-keyword">if</span> (root == NIL) <span class="hljs-keyword">return</span> NIL; <span class="hljs-comment">// 说明当前树没有要删除的节点</span><br>    <span class="hljs-keyword">if</span> (key &lt; root-&gt;key) root-&gt;left = __erase(root-&gt;left, key);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &gt; root-&gt;key) root-&gt;right = __erase(root-&gt;right, key);<br>    <span class="hljs-comment">// 找到了</span><br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">// 度为1或0的情况</span><br>        <span class="hljs-keyword">if</span> (root-&gt;left == NIL || root-&gt;right == NIL)<br>        &#123;<br>            TreeNode *node = root-&gt;left != NIL ? root-&gt;left : root-&gt;right;<br>            node-&gt;color += root-&gt;color; <span class="hljs-comment">// 将当前节点的颜色加到子节点中去</span><br>            <span class="hljs-built_in">free</span>(root);<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-comment">// 删除度为2的节点的情况</span><br>        &#123;<br>            TreeNode *temp = <span class="hljs-built_in">predecessor</span>(root); <span class="hljs-comment">// 找到它的前驱</span><br>            root-&gt;key = temp-&gt;key;<br>            root-&gt;left = __erase(root-&gt;left, temp-&gt;key); <span class="hljs-comment">// 到左子树中删除值为temp-&gt;key的节点</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">erase_maintain</span>(root);<br>&#125;<br><br><span class="hljs-function">TreeNode *<span class="hljs-title">erase</span><span class="hljs-params">(TreeNode *root, <span class="hljs-type">int</span> key)</span></span><br><span class="hljs-function"></span>&#123;<br>    root = __erase(root, key);<br>    root-&gt;color = <span class="hljs-number">1</span>; <span class="hljs-comment">//强制将root的颜色改为黑色</span><br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><br><span class="hljs-comment">// 插入调整</span><br><span class="hljs-function">TreeNode *<span class="hljs-title">insert_maintain</span><span class="hljs-params">(TreeNode *root)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">has_red_child</span>(root)) <span class="hljs-keyword">return</span> root; <span class="hljs-comment">// 如果没有红节点，不用调整</span><br>    <span class="hljs-comment">// 若有冲突此时分两种情况 1、左右子树都为红；2、一红一黑</span><br>    <span class="hljs-keyword">if</span> (root-&gt;left-&gt;color == <span class="hljs-number">0</span> &amp;&amp; root-&gt;right-&gt;color == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">has_red_child</span>(root-&gt;left) || <span class="hljs-built_in">has_red_child</span>(root-&gt;right))<br>        &#123;<br>            root-&gt;color = <span class="hljs-number">0</span>;<br>            root-&gt;left-&gt;color = root-&gt;right-&gt;color = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> flag = <span class="hljs-number">0</span>; <span class="hljs-comment">//1:冲突发生在左子树；2：冲突发生在右子树</span><br>    <span class="hljs-keyword">if</span> (root-&gt;left-&gt;color == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">has_red_child</span>(root-&gt;left))   flag = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (root-&gt;right-&gt;color == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">has_red_child</span>(root-&gt;right)) flag = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (flag == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> root;<br>    <span class="hljs-keyword">if</span> (flag == <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (root-&gt;left-&gt;right-&gt;color == <span class="hljs-number">0</span>) root-&gt;left = <span class="hljs-built_in">left_rotate</span>(root-&gt;left);<br>        root = <span class="hljs-built_in">right_rotate</span>(root);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (root-&gt;right-&gt;left-&gt;color == <span class="hljs-number">0</span>) root-&gt;right = <span class="hljs-built_in">right_rotate</span>(root-&gt;right);<br>        root = <span class="hljs-built_in">left_rotate</span>(root);<br>    &#125;<br>    root-&gt;color = <span class="hljs-number">0</span>;<br>    root-&gt;left-&gt;color = root-&gt;right-&gt;color = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><br><span class="hljs-comment">//插入</span><br>TreeNode *__insert(TreeNode *root, <span class="hljs-type">int</span> key)<br>&#123;<br>    <span class="hljs-keyword">if</span> (root == NIL) <span class="hljs-keyword">return</span> <span class="hljs-built_in">getNewNode</span>(key);<br>    <span class="hljs-keyword">if</span> (root-&gt;key == key) <span class="hljs-keyword">return</span> root;<br>    <span class="hljs-keyword">if</span> (key &gt; root-&gt;key) root-&gt;right = __insert(root-&gt;right, key);<br>    <span class="hljs-keyword">else</span> root-&gt;left = __insert(root-&gt;left, key);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">insert_maintain</span>(root);<br>&#125;<br><br><span class="hljs-function">TreeNode *<span class="hljs-title">insert</span><span class="hljs-params">(TreeNode *root, <span class="hljs-type">int</span> key)</span></span><br><span class="hljs-function"></span>&#123;<br>    root = __insert(root, key);<br>    root-&gt;color = <span class="hljs-number">1</span>; <span class="hljs-comment">////强制将root的颜色改为黑色</span><br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(TreeNode *root)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout  &lt;&lt; root-&gt;color &lt;&lt;  root-&gt;key &lt;&lt; root-&gt;left-&gt;key &lt;&lt; root-&gt;right-&gt;key &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">output</span><span class="hljs-params">(TreeNode *root)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (root == NIL) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">print</span>(root);<br>    <span class="hljs-built_in">output</span>(root-&gt;left);<br>    <span class="hljs-built_in">output</span>(root-&gt;right);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
